"use strict";(self.webpackChunkangular_17_test=self.webpackChunkangular_17_test||[]).push([[6062],{8868:(bt,kt,tt)=>{tt.d(kt,{Z:()=>dt});var z=tt(50484),xt=tt(57964),ct=tt(89317),ut=tt(34222),ft=tt(4703),W=tt(80543),pt=tt(73018),yt=tt(10141);class mt{constructor(C=null,G=null,J=null){this.minValue=C,this.maxValue=G,this.noDataValue=J}}var at,rt=tt(86741);let nt=at=class extends ct.wq{static createEmptyBand(T,C){return new(at.getPixelArrayConstructor(T))(C)}static getPixelArrayConstructor(T){let C;switch(T){case"u1":case"u2":case"u4":case"u8":C=Uint8Array;break;case"u16":C=Uint16Array;break;case"u32":C=Uint32Array;break;case"s8":C=Int8Array;break;case"s16":C=Int16Array;break;case"s32":C=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":C=Float32Array;break;case"f64":C=Float64Array}return C}constructor(T){super(T),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(T){if(!T)return"f32";let C=T.toLowerCase();return["u1","u2","u4"].includes(C)?C="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(C)||(C="f32"),C}getPlaneCount(){return this.pixels?.length}addData(T){if(!T.pixels||T.pixels.length!==this.width*this.height)throw new xt.Z("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(T.pixels),this.statistics.push(T.statistics??new mt)}getAsRGBA(){const T=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(T);break;default:this._fillFrom8Bit(T)}return new Uint8ClampedArray(T)}getAsRGBAFloat(){const T=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(T),T}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(G=>this._calculateBandStatistics(G,this.mask));const T=this.mask;let C=0;if(null!=T)for(let G=0;G<T.length;G++)T[G]&&C++;else C=this.width*this.height;this.validPixelCount=C}clamp(T){if(!T||"f64"===T||"f32"===T||!this.pixels)return;const[C,G]=(0,rt.r)(T),J=this.pixels,X=this.width*this.height,O=J.length;let S,Y,Z;const $=[];for(let et=0;et<O;et++){Z=at.createEmptyBand(T,X),S=J[et];for(let N=0;N<X;N++)Y=S[N],Z[N]=Y>G?G:Y<C?C:Y;$.push(Z)}this.pixels=$,this.pixelType=T}extractBands(T){const{pixels:C,statistics:G}=this;if(null==T||0===T.length||!C||0===C.length)return this;const J=C.length,X=T.some(N=>N>=C.length),O=J===T.length&&!T.some((N,I)=>N!==I);if(X||O)return this;const S=this.bandMasks?.length===J?T.map(N=>this.bandMasks[N]):void 0;let{mask:Y,validPixelCount:Z}=this;const{width:$,height:et}=this;if(S){if(1===S.length)Y=S[0];else{const N=$*et;Y=new Uint8Array(N).fill(255);for(let I=0;I<S.length;I++){const b=S[I];for(let E=0;E<N;E++)b[E]||(Y[E]=0)}}Z=Y.filter(N=>!!N).length}return new at({pixelType:this.pixelType,width:$,height:et,mask:Y,bandMasks:S,validPixelCount:Z,maskIsAlpha:this.maskIsAlpha,pixels:T.map(N=>C[N]),statistics:G&&T.map(N=>G[N])})}clone(){const T=new at({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let C;null!=this.mask&&(T.mask=this.mask instanceof Uint8Array?new Uint8Array(this.mask):this.mask.slice(0)),this.bandMasks&&(T.bandMasks=this.bandMasks.map(J=>new Uint8Array(J)));const G=at.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){T.pixels=[];const J=!!this.pixels[0].slice;for(C=0;C<this.pixels.length;C++)T.pixels[C]=J?this.pixels[C].slice(0,this.pixels[C].length):new G(this.pixels[C])}if(this.statistics)for(T.statistics=[],C=0;C<this.statistics.length;C++)T.statistics[C]=(0,ut.d9)(this.statistics[C]);return T.premultiplyAlpha=this.premultiplyAlpha,T}_fillFrom8Bit(T){const{mask:C,maskIsAlpha:G,premultiplyAlpha:J,pixels:X}=this;if(!T||!X?.length)return void ft.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let O,S,Y,Z;O=S=Y=X[0],X.length>=3?(S=X[1],Y=X[2]):2===X.length&&(S=X[1]);const $=new Uint32Array(T),et=this.width*this.height;if(O.length===et)if(null!=C&&C.length===et)if(G)for(Z=0;Z<et;Z++){const N=C[Z];if(N){const I=N/255;$[Z]=J?N<<24|Y[Z]*I<<16|S[Z]*I<<8|O[Z]*I:N<<24|Y[Z]<<16|S[Z]<<8|O[Z]}}else for(Z=0;Z<et;Z++)C[Z]&&($[Z]=255<<24|Y[Z]<<16|S[Z]<<8|O[Z]);else for(Z=0;Z<et;Z++)$[Z]=255<<24|Y[Z]<<16|S[Z]<<8|O[Z];else ft.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(T){const{pixels:C,mask:G,statistics:J}=this;if(!T||!C?.length)return void ft.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const X=this.pixelType;let O=1,S=0,Y=1;if(J&&J.length>0){for(const D of J)null!=D.minValue&&(S=Math.min(S,D.minValue)),null!=D.maxValue&&null!=D.minValue&&(Y=Math.max(Y,D.maxValue-D.minValue));O=255/Y}else{let D=255;"s8"===X?(S=-128,D=127):"u16"===X?D=65535:"s16"===X?(S=-32768,D=32767):"u32"===X?D=4294967295:"s32"===X?(S=-2147483648,D=2147483647):"f32"===X?(S=-34e38,D=34e38):"f64"===X&&(S=-Number.MAX_VALUE,D=Number.MAX_VALUE),O=255/(D-S)}const Z=new Uint32Array(T),$=this.width*this.height;let et,N,I,b,E;if(et=N=I=C[0],et.length!==$)return ft.Z.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(C.length>=2)if(N=C[1],C.length>=3&&(I=C[2]),null!=G&&G.length===$)for(b=0;b<$;b++)G[b]&&(Z[b]=255<<24|(I[b]-S)*O<<16|(N[b]-S)*O<<8|(et[b]-S)*O);else for(b=0;b<$;b++)Z[b]=255<<24|(I[b]-S)*O<<16|(N[b]-S)*O<<8|(et[b]-S)*O;else if(null!=G&&G.length===$)for(b=0;b<$;b++)E=(et[b]-S)*O,G[b]&&(Z[b]=255<<24|E<<16|E<<8|E);else for(b=0;b<$;b++)E=(et[b]-S)*O,Z[b]=255<<24|E<<16|E<<8|E}_fillFrom32Bit(T){const{pixels:C,mask:G}=this;if(!T||!C?.length)return ft.Z.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let J,X,O,S;J=X=O=C[0],C.length>=3?(X=C[1],O=C[2]):2===C.length&&(X=C[1]);const Y=this.width*this.height;if(J.length!==Y)return ft.Z.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let Z=0;if(null!=G&&G.length===Y)for(S=0;S<Y;S++)T[Z++]=J[S],T[Z++]=X[S],T[Z++]=O[S],T[Z++]=1&G[S];else for(S=0;S<Y;S++)T[Z++]=J[S],T[Z++]=X[S],T[Z++]=O[S],T[Z++]=1}_calculateBandStatistics(T,C){let G=1/0,J=-1/0;const X=T.length;let O,S=0;if(null!=C)for(O=0;O<X;O++)C[O]&&(S=T[O],G=S<G?S:G,J=S>J?S:J);else for(O=0;O<X;O++)S=T[O],G=S<G?S:G,J=S>J?S:J;return new mt(G,J)}};(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"width",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"height",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"pixelType",void 0),(0,z._)([(0,pt.p)("pixelType")],nt.prototype,"castPixelType",null),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"validPixelCount",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"mask",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"maskIsAlpha",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"pixels",void 0),(0,z._)([(0,W.Cb)()],nt.prototype,"premultiplyAlpha",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"statistics",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"depthCount",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"noDataValues",void 0),(0,z._)([(0,W.Cb)({json:{write:!0}})],nt.prototype,"bandMasks",void 0),nt=at=(0,z._)([(0,yt.j)("esri.layers.support.PixelBlock")],nt);const dt=nt},86741:(bt,kt,tt)=>{tt.d(kt,{A:()=>ft,r:()=>ut});const z=9999999e31,xt=2e-7,ct={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34028234663852886e22,34028234663852886e22],f64:[-Number.MAX_VALUE,Number.MAX_VALUE],unknown:void 0,c64:void 0,c128:void 0};function ut(W){return ct[W]??[-34028234663852886e22,34028234663852886e22]}function ft(W,pt,yt){if(W.depthCount&&W.depthCount>1)return;const{pixels:mt,statistics:rt,pixelType:at}=W,dt=W.bandMasks??[],T=W.mask??new Uint8Array(mt[0].length).fill(255),C="f32"===at||"f64"===at,G=ut(at);let J=!1;for(let X=0;X<mt.length;X++){const O="number"==typeof pt?pt:pt[X];if(null==O)continue;if((rt?.[X]?.minValue??G[0])>O+Number.EPSILON||(rt?.[X]?.maxValue??G[1])<O-Number.EPSILON)continue;const Z=dt[X]||T.slice(),$=mt[X],et=yt?.customFloatTolerance;if(C&&0!==et){let N=et;N||(N=Math.abs(O)>=z?xt*Math.abs(O):"f32"===at?2**-23:Number.EPSILON);for(let I=0;I<$.length;I++)Z[I]&&Math.abs($[I]-O)<N&&($[I]=0,Z[I]=0,T[I]=0,J=!0)}else for(let N=0;N<$.length;N++)Z[N]&&$[N]===O&&($[N]=0,Z[N]=0,T[N]=0,J=!0);dt[X]=Z}J&&(W.bandMasks=W.bandMasks||W.pixels.length>1?dt:null,W.mask=T),J&&"updateStatistics"in W&&W.updateStatistics()}},98797:(bt,kt,tt)=>{tt.d(kt,{$f:()=>ft,CD:()=>ut,DX:()=>ct,Gd:()=>yt,Kh:()=>Z,Pz:()=>mt,Qh:()=>g,SJ:()=>rt,Uk:()=>x,Vl:()=>w,XV:()=>at,a2:()=>T,nA:()=>S,nk:()=>W,oB:()=>O,pW:()=>I,sS:()=>X,us:()=>et,wV:()=>nt,zp:()=>dt});var ct,ut,t,z=tt(8868),xt=tt(86741);(t=ct||(ct={}))[t.matchAny=0]="matchAny",t[t.matchAll=1]="matchAll",function(t){t[t.bestMatch=0]="bestMatch",t[t.fail=1]="fail"}(ut||(ut={}));const ft=6;function W(t){return null!=t&&"esri.layers.support.PixelBlock"===t.declaredClass&&t.pixels&&t.pixels.length>0}function yt(t){if(!t?.length||t.some(n=>!W(n)))return null;if(1===t.length)return t[0]?.clone()??null;const s=t,{width:e,height:i,pixelType:o}=s[0];if(s.some(n=>n.width!==e||n.height!==i))return null;const l=s.map(({mask:n})=>n).filter(n=>null!=n);let a=null;l.length&&(a=new Uint8Array(e*i),a.set(l[0]),l.length>1&&J(l.slice(1),a));const r=[];s.forEach(({pixels:n})=>r.push(...n));const u=s.map(({statistics:n})=>n).filter(n=>n?.length),c=[];return u.forEach(n=>c.push(...n)),new z.Z({pixelType:o,width:e,height:i,mask:a,pixels:r,statistics:c.length?c:null})}function mt(t){if(!t)return;const s=t.colormap;if(!s||0===s.length)return;const e=s.sort((h,y)=>h[0]-y[0]);let i=0;e[0][0]<0&&(i=e[0][0]);const o=Math.max(256,e[e.length-1][0]-i+1),l=new Uint8Array(4*o),a=[];let r,u=0,c=0;const n=5===e[0].length;if(o>65536)return e.forEach(h=>{a[h[0]-i]=n?h.slice(1):h.slice(1).concat([255])}),{indexed2DColormap:a,offset:i,alphaSpecified:n};if(t.fillUnspecified)for(r=e[c],u=r[0]-i;u<o;u++)l[4*u]=r[1],l[4*u+1]=r[2],l[4*u+2]=r[3],l[4*u+3]=n?r[4]:255,u===r[0]-i&&(r=c===e.length-1?r:e[++c]);else for(u=0;u<e.length;u++)r=e[u],c=4*(r[0]-i),l[c]=r[1],l[c+1]=r[2],l[c+2]=r[3],l[c+3]=n?r[4]:255;return{indexedColormap:l,offset:i,alphaSpecified:n}}function rt(t,s){if(!W(t)||!s||!s.indexedColormap&&!s.indexed2DColormap)return t;const e=t.clone(),i=e.pixels;let o=e.mask;const l=e.width*e.height;if(1!==i.length)return t;const{indexedColormap:a,indexed2DColormap:r,offset:u,alphaSpecified:c}=s;let n=0;const h=i[0],y=new Uint8Array(h.length),f=new Uint8Array(h.length),m=new Uint8Array(h.length);let p,M=0;if(a){const _=a.length-1;if(null!=o)for(n=0;n<l;n++)o[n]&&(M=4*(h[n]-u),M<u||M>_?o[n]=0:(y[n]=a[M],f[n]=a[M+1],m[n]=a[M+2],o[n]=a[M+3]));else{for(o=new Uint8Array(l),n=0;n<l;n++)M=4*(h[n]-u),M<u||M>_?o[n]=0:(y[n]=a[M],f[n]=a[M+1],m[n]=a[M+2],o[n]=a[M+3]);e.mask=o}}else if(r)if(null!=o)for(n=0;n<l;n++)o[n]&&(p=r[h[n]],y[n]=p[0],f[n]=p[1],m[n]=p[2],o[n]=p[3]);else{for(o=new Uint8Array(l),n=0;n<l;n++)p=r[h[n]],y[n]=p[0],f[n]=p[1],m[n]=p[2],o[n]=p[3];e.mask=o}return e.pixels=[y,f,m],e.statistics=null,e.pixelType="u8",e.maskIsAlpha=c,e}function at(t,s){if(!W(t))return null;const{pixels:e,mask:i}=t,o=e.length;let l=s.lut;const{offset:a}=s;l&&1===l[0].length&&(l=e.map(()=>l));const r=[],u=s.outputPixelType||"u8";for(let n=0;n<o;n++){const h=nt(e[n],i,l[n],a||0,u);r.push(h)}const c=new z.Z({width:t.width,height:t.height,pixels:r,mask:i,pixelType:u});return c.updateStatistics(),c}function nt(t,s,e,i,o){const l=t.length,a=z.Z.createEmptyBand(o,l);if(s)for(let r=0;r<l;r++)s[r]&&(a[r]=e[t[r]-i]);else for(let r=0;r<l;r++)a[r]=e[t[r]-i];return a}function dt(t,s){if(!W(t))return null;const e=t.clone(),{pixels:i}=e,o=e.width*e.height,l=s.length,a=Math.floor(l/2),r=s[Math.floor(a)],u=i[0];let c,n,h,y,f,m,p=!1;const M=new Uint8Array(o),_=new Uint8Array(o),P=new Uint8Array(o);let V=e.mask;const v=4===s[0].mappedColor.length;for(V||(V=new Uint8Array(o),V.fill(v?255:1),e.mask=V),f=0;f<o;f++)if(V[f]){for(c=u[f],p=!1,m=a,n=r,h=0,y=l-1;y-h>1;){if(c===n.value){p=!0;break}c>n.value?h=m:y=m,m=Math.floor((h+y)/2),n=s[Math.floor(m)]}p||(c===s[h].value?(n=s[h],p=!0):c===s[y].value?(n=s[y],p=!0):c<s[h].value?(p=!1,n=null):c>s[h].value&&(c<s[y].value?(n=s[h],p=!0):y===l-1?(p=!1,n=null):(n=s[y],p=!0))),p?(M[f]=n.mappedColor[0],_[f]=n.mappedColor[1],P[f]=n.mappedColor[2],V[f]=n.mappedColor[3]):M[f]=_[f]=P[f]=V[f]=0}return e.pixels=[M,_,P],e.mask=V,e.pixelType="u8",e.maskIsAlpha=v,e}function T(t,s){if(!W(t))return null;const{width:e,height:i}=t,{inputRanges:o,outputValues:l,outputPixelType:a,noDataRanges:r,allowUnmatched:u,isLastInputRangeInclusive:c}=s,n=t.pixels[0],h=z.Z.createEmptyBand(a,n.length),y=t.mask,f=new Uint8Array(e*i);y?f.set(y):f.fill(255);const m=t.pixelType.startsWith("f")?1e-6:0,p=o.map(v=>v-m);p[0]=o[0],p[p.length-1]=o[o.length-1]+(c?1e-6:0);const M=o.length/2,[_,P]=(0,xt.r)(a);for(let v=0;v<i;v++)for(let U=0;U<e;U++){const L=v*e+U;if(f[L]){const B=n[L];let K=!1;for(let Q=M-1;Q>=0;Q--)if(B===p[2*Q]||B>p[2*Q]&&B<p[2*Q+1]){h[L]=l[Q],K=!0;break}K||(u?h[L]=B>P?P:B<_?_:B:f[L]=0)}}const V=r?.length;if(V)for(let v=0;v<i;v++)for(let U=0;U<e;U++){const L=v*e+U;if(!y||y[L]){const B=n[L];for(let K=0;K<V;K+=2)if(B>=r[K]&&B<=r[K+1]){h[L]=0,f[L]=0;break}}}return new z.Z({width:e,height:i,pixelType:a,pixels:[h],mask:f})}function C(t,s,e,i){const o=null!=e&&e.length>=2?new Set(e):null,l=1===e?.length?e[0]:null,a=!!s?.length;for(let r=0;r<t.length;r++)if(i[r]){const u=t[r];if(a){let c=!1;for(let n=0;n<s.length;n+=2)if(u>=s[n]&&u<=s[n+1]){c=!0;break}c||(i[r]=0)}i[r]&&(u===l||o?.has(u))&&(i[r]=0)}}function G(t,s){const e=t[0].length;for(let i=0;i<e;i++)if(s[i]){let o=!1;for(let l=0;l<t.length;l++)if(t[l][i]){o=!0;break}o||(s[i]=0)}}function J(t,s){const e=t[0].length;for(let i=0;i<e;i++)if(s[i]){let o=!1;for(let l=0;l<t.length;l++)if(0===t[l][i]){o=!0;break}o&&(s[i]=0)}}function X(t,s){if(!W(t))return null;const{width:e,height:i,pixels:o}=t,l=e*i,a=new Uint8Array(l);t.mask?a.set(t.mask):a.fill(255);const r=o.length,{includedRanges:u,noDataValues:c,outputPixelType:n,matchAll:h,lookups:y}=s;if(y){const f=[];for(let m=0;m<r;m++){const p=y[m],M=nt(o[m],a,p.lut,p.offset||0,"u8");f.push(M)}1===f.length?a.set(f[0]):h?G(f,a):J(f,a)}else if(h){const f=[];for(let m=0;m<r;m++){const p=new Uint8Array(l);p.set(a),C(o[m],u?.slice(2*m,2*m+2),c?.[m],p),f.push(p)}1===f.length?a.set(f[0]):G(f,a)}else for(let f=0;f<r;f++)C(o[f],u?.slice(2*f,2*f+2),c?.[f],a);return new z.Z({width:e,height:i,pixelType:n,pixels:o,mask:a})}function O(t){const{srcPixelType:s,inputRanges:e,outputValues:i,allowUnmatched:o,noDataRanges:l,isLastInputRangeInclusive:a,outputPixelType:r}=t;if("u8"!==s&&"s8"!==s&&"u16"!==s&&"s16"!==s)return null;const u=s.includes("16")?65536:256,c=s.includes("s")?-u/2:0,n=z.Z.createEmptyBand(r,u),h=new Uint8Array(u);o&&h.fill(255);const[y,f]=(0,xt.r)(r);if(e?.length&&i?.length){const p=e.map(M=>M-1e-6);p[0]=e[0],a&&(p[p.length-1]=e[e.length-1]);for(let M=0;M<p.length;M++){const _=i[M]>f?f:i[M]<y?y:i[M],P=Math.ceil(p[2*M]-c),V=Math.floor(p[2*M+1]-c);for(let v=P;v<=V;v++)n[v]=_,h[v]=255}}if(l?.length)for(let m=0;m<l.length;m++){const p=Math.ceil(l[2*m]-c),M=Math.floor(l[2*m+1]-c);for(let _=p;_<=M;_++)h[_]=0}return{lut:n,offset:c,mask:h}}function S(t,s,e){if("u8"!==t&&"s8"!==t&&"u16"!==t&&"s16"!==t)return null;const i=t.includes("16")?65536:256,o=t.includes("s")?-i/2:0,l=new Uint8Array(i);if(s)for(let a=0;a<s.length;a++){const r=Math.ceil(s[2*a]-o),u=Math.floor(s[2*a+1]-o);for(let c=r;c<=u;c++)l[c]=255}else l.fill(255);if(e)for(let a=0;a<e.length;a++)l[e[a]-o]=0;return{lut:l,offset:o}}function Z(t,s){if(!t||0===t.length)return null;const e=t.find(m=>m.pixelBlock);if(null==e?.pixelBlock)return null;const i=(e.extent.xmax-e.extent.xmin)/e.pixelBlock.width,o=(e.extent.ymax-e.extent.ymin)/e.pixelBlock.height,l=.01*Math.min(i,o),a=t.sort((m,p)=>Math.abs(m.extent.ymax-p.extent.ymax)>l?p.extent.ymax-m.extent.ymax:Math.abs(m.extent.xmin-p.extent.xmin)>l?m.extent.xmin-p.extent.xmin:0),r=Math.min.apply(null,a.map(m=>m.extent.xmin)),u=Math.min.apply(null,a.map(m=>m.extent.ymin)),c=Math.max.apply(null,a.map(m=>m.extent.xmax)),n=Math.max.apply(null,a.map(m=>m.extent.ymax)),h={x:Math.round((s.xmin-r)/i),y:Math.round((n-s.ymax)/o)},y={width:Math.round((c-r)/i),height:Math.round((n-u)/o)},f={width:Math.round((s.xmax-s.xmin)/i),height:Math.round((s.ymax-s.ymin)/o)};return Math.round(y.width/e.pixelBlock.width)*Math.round(y.height/e.pixelBlock.height)!==a.length||h.x<0||h.y<0||y.width<f.width||y.height<f.height?null:{extent:s,pixelBlock:et(a.map(m=>m.pixelBlock),y,{clipOffset:h,clipSize:f})}}function $(t,s,e,i,o,l){const{width:a,height:r}=e.block,{x:u,y:c}=e.offset,{width:n,height:h}=e.mosaic,y=function Y(t,s,e,i,o,l,a,r){return{xmin:o<=e*t?0:o<e*t+t?o-e*t:t,ymin:l<=i*s?0:l<i*s+s?l-i*s:s,xmax:o+a<=e*t?0:o+a<e*t+t?o+a-e*t:t,ymax:l+r<=i*s?0:l+r<i*s+s?l+r-i*s:s}}(a,r,i,o,u,c,n,h);let f=0,m=0;if(l){const p=l.hasGCSSShiftTransform?360:l.halfWorldWidth??0,M=a*l.resolutionX,_=l.startX+i*M;_<p&&_+M>p?m=l.rightPadding:_>=p&&(f=l.leftMargin-l.rightPadding,m=0)}if(y.xmax-=m,"number"!=typeof s)for(let p=y.ymin;p<y.ymax;p++){const M=(o*r+p-c)*n+(i*a-u)+f,_=p*a;for(let P=y.xmin;P<y.xmax;P++)t[M+P]=s[_+P]}else for(let p=y.ymin;p<y.ymax;p++){const M=(o*r+p-c)*n+(i*a-u)+f;for(let _=y.xmin;_<y.xmax;_++)t[M+_]=s}}function et(t,s,e={}){const{clipOffset:i,clipSize:o,alignmentInfo:l,blockWidths:a}=e;if(a)return function N(t,s,e){const i=t.find(M=>null!=M);if(null==i)return null;const o=t.some(M=>null==M||!!M.mask),{width:l,height:a}=s,r=o?new Uint8Array(l*a):null,{blockWidths:u}=e,c=[],n=i.getPlaneCount(),h=z.Z.getPixelArrayConstructor(i.pixelType);if(o)for(let M=0,_=0;M<t.length;_+=u[M],M++){const P=t[M];if(!W(P))continue;const V=P.mask;for(let v=0;v<a;v++)for(let U=0;U<u[M];U++)r[v*l+U+_]=null==V?255:V[v*P.width+U]}const y=t.some(M=>M?.bandMasks&&M.bandMasks.length>1),f=y?[]:void 0,m=l*a;for(let M=0;M<n;M++){const _=new h(m),P=y?new Uint8Array(m):void 0;for(let V=0,v=0;V<t.length;v+=u[V],V++){const U=t[V];if(!W(U))continue;const L=U.pixels[M];if(null!=L){for(let B=0;B<a;B++)for(let K=0;K<u[V];K++)_[B*l+K+v]=L[B*U.width+K];if(P){const B=U.bandMasks?.[M]??U.mask;for(let K=0;K<a;K++)for(let Q=0;Q<u[V];Q++)P[K*l+Q+v]=B?B[K*U.width+Q]:255}}}c.push(_),f&&P&&f.push(P)}const p=new z.Z({width:l,height:a,mask:r,bandMasks:f,pixels:c,pixelType:i.pixelType});return p.updateStatistics(),p}(t,s,{blockWidths:a});const r=t.find(j=>W(j));if(null==r)return null;const u=o?o.width:s.width,c=o?o.height:s.height,n=r.width,h=r.height,y=s.width/n,f=s.height/h,m={offset:i||{x:0,y:0},mosaic:o||s,block:{width:n,height:h}},p=r.pixelType,M=z.Z.getPixelArrayConstructor(p),_=r.pixels.length,P=[];let V,v;for(let j=0;j<_;j++){v=new M(u*c);for(let H=0;H<f;H++)for(let F=0;F<y;F++){const q=t[H*y+F];W(q)&&(V=q.pixels[j],$(v,V,m,F,H,l))}P.push(v)}const U=t.some(j=>null==j||null!=j.mask&&j.mask.length>0),L=t.some(j=>j?.bandMasks&&j.bandMasks.length>1),B=U?new Uint8Array(u*c):void 0,K=L?[]:void 0;if(B){for(let j=0;j<f;j++)for(let H=0;H<y;H++){const F=t[j*y+H];$(B,(null!=F?F.mask:null)??(F?255:0),m,H,j,l)}if(K)for(let j=0;j<_;j++){const H=new Uint8Array(u*c);for(let F=0;F<f;F++)for(let q=0;q<y;q++){const ht=t[F*y+q];$(H,ht?.bandMasks?.[j]??ht?.mask??(ht?255:0),m,q,F,l)}K.push(H)}}const Q=new z.Z({width:u,height:c,pixels:P,pixelType:p,bandMasks:K,mask:B});return Q.updateStatistics(),Q}function I(t,s,e){if(!W(t))return null;const{width:i,height:o}=t,l=s.x,a=s.y,r=e.width+l,u=e.height+a;if(l<0||a<0||r>i||u>o||0===l&&0===a&&r===i&&u===o)return t;t.mask||(t.mask=new Uint8Array(i*o));const c=t.mask;for(let n=0;n<o;n++){const h=n*i;for(let y=0;y<i;y++)c[h+y]=n<a||n>=u||y<l||y>=r?0:1}return t.updateStatistics(),t}function E(t){if(0===t.size)return 0;let s=0,e=-1,i=0;const o=t.keys();let l=o.next();for(;!l.done;)i=t.get(l.value),i>s&&(e=l.value,s=i),l=o.next();return e}function D(t,s,e){if(0===e)return;const i=t.get(s);1===i?t.delete(s):t.set(s,i-1)}function R(t,s,e){0!==e&&t.set(s,t.has(s)?t.get(s)+1:1)}function d(t,s,e){let{x:i,y:o}=s;const{width:l,height:a}=e;if(0===i&&0===o&&a===t.height&&l===t.width)return t;const{width:r,height:u}=t,c=Math.max(0,o),n=Math.max(0,i),h=Math.min(i+l,r),y=Math.min(o+a,u);if(h<0||y<0||!W(t))return null;i=Math.max(0,-i),o=Math.max(0,-o);const{pixels:f}=t,m=l*a,p=f.length,M=[];for(let v=0;v<p;v++){const U=f[v],L=z.Z.createEmptyBand(t.pixelType,m);for(let B=c;B<y;B++){const K=B*r;let Q=(B+o-c)*l+i;for(let j=n;j<h;j++)L[Q++]=U[K+j]}M.push(L)}const _=new Uint8Array(m),P=t.mask;for(let v=c;v<y;v++){const U=v*r;let L=(v+o-c)*l+i;for(let B=n;B<h;B++)_[L++]=P?P[U+B]:1}const V=new z.Z({width:e.width,height:e.height,pixelType:t.pixelType,pixels:M,mask:_});return V.updateStatistics(),V}function k(t,s=!0){if(!W(t))return null;const{pixels:e,width:i,height:o,mask:l,pixelType:a}=t,r=[],u=Math.round(i/2),c=Math.round(o/2),n=o-1,h=i-1;for(let f=0;f<e.length;f++){const m=e[f],p=z.Z.createEmptyBand(a,u*c);let M=0;for(let _=0;_<o;_+=2)for(let P=0;P<i;P+=2){const V=m[_*i+P];if(s){const v=P===h?V:m[_*i+P+1],U=_===n?V:m[_*i+P+i];p[M++]=(V+v+U+(P===h?U:_===n?v:m[_*i+P+i+1]))/4}else p[M++]=V}r.push(p)}let y=null;if(null!=l){y=new Uint8Array(u*c);let f=0;for(let m=0;m<o;m+=2)for(let p=0;p<i;p+=2){const M=l[m*i+p];if(s){const _=p===h?M:l[m*i+p+1],P=m===n?M:l[m*i+p+i];y[f++]=M*_*P*(p===h?P:m===n?_:l[m*i+p+i+1])?1:0}else y[f++]=M}}return new z.Z({width:u,height:c,pixelType:a,pixels:r,mask:y})}function w(t,s,e){if(!W(t))return null;const{width:i,height:o}=s;let{width:l,height:a}=t;const r=new Map,u={x:0,y:0},c=null==e?1:1+e;let n=t;for(let h=0;h<c;h++){const y=Math.ceil(l/i),f=Math.ceil(a/o);for(let m=0;m<f;m++){u.y=m*o;for(let p=0;p<y;p++){u.x=p*i;const M=d(n,u,s);r.set(`${h}/${m}/${p}`,M)}}h<c-1&&(n=k(n)),l=Math.round(l/2),a=Math.round(a/2)}return r}function A(t,s,e,i,o=0){const{width:l,height:a}=t,{width:r,height:u}=s,c=i.cols,n=i.rows,h=Math.ceil(r/c-.1/c),y=Math.ceil(u/n-.1/n);let f,m,p,M,_,P,V;const v=h*c,U=v*y*n,L=new Float32Array(U),B=new Float32Array(U),K=new Uint32Array(U),Q=new Uint32Array(U);let j,H,F=0;for(let q=0;q<y;q++)for(let ht=0;ht<h;ht++){f=12*(q*h+ht),m=e[f],p=e[f+1],M=e[f+2],_=e[f+3],P=e[f+4],V=e[f+5];for(let ot=0;ot<n;ot++){F=(q*n+ot)*v+ht*c,H=(ot+.5)/n;for(let lt=0;lt<ot;lt++)j=(lt+.5)/c,L[F+lt]=(m*j+p*H+M)*l+o,B[F+lt]=(_*j+P*H+V)*a+o,K[F+lt]=Math.floor(L[F+lt]),Q[F+lt]=Math.floor(B[F+lt])}f+=6,m=e[f],p=e[f+1],M=e[f+2],_=e[f+3],P=e[f+4],V=e[f+5];for(let ot=0;ot<n;ot++){F=(q*n+ot)*v+ht*c,H=(ot+.5)/n;for(let lt=ot;lt<c;lt++)j=(lt+.5)/c,L[F+lt]=(m*j+p*H+M)*l+o,B[F+lt]=(_*j+P*H+V)*a+o,K[F+lt]=Math.floor(L[F+lt]),Q[F+lt]=Math.floor(B[F+lt])}}return{offsets_x:L,offsets_y:B,offsets_xi:K,offsets_yi:Q,gridWidth:v}}function g(t,s){const{coefficients:e,spacing:i}=s,{offsets_x:o,offsets_y:l,gridWidth:a}=A(t,t,e,{rows:i[0],cols:i[1]}),{width:r,height:u}=t,c=new Float32Array(r*u),n=180/Math.PI;for(let h=0;h<u;h++)for(let y=0;y<r;y++){const f=h*a+y,m=0===h?f:f-a,p=h===u-1?f:f+a,M=o[m]-o[p],_=l[p]-l[m];if(isNaN(M)||isNaN(_))c[h*r+y]=90;else{let P=Math.atan2(_,M)*n;P=(360+P)%360,c[h*r+y]=P}}return c}function x(t,s,e,i,o="nearest"){if(!W(t))return null;"majority"===o&&(t=function b(t){if(!W(t))return null;const s=t.clone(),{width:e,height:i,pixels:o}=t,l=o[0],a=s.pixels[0],r=t.mask;for(let u=2;u<i-1;u++){const c=new Map;for(let h=u-2;h<u+2;h++)for(let y=0;y<4;y++){const f=h*e+y;R(c,l[f],r?r[f]:1)}a[u*e]=E(c),a[u*e+1]=a[u*e+2]=a[u*e];let n=3;for(;n<e-1;n++){let h=(u-2)*e+n+1;R(c,l[h],r?r[h]:1),h=(u-1)*e+n+1,R(c,l[h],r?r[h]:1),h=u*e+n+1,R(c,l[h],r?r[h]:1),h=(u+1)*e+n+1,R(c,l[h],r?r[h]:1),h=(u-2)*e+n-3,D(c,l[h],r?r[h]:1),h=(u-1)*e+n-3,D(c,l[h],r?r[h]:1),h=u*e+n-3,D(c,l[h],r?r[h]:1),h=(u+1)*e+n-3,D(c,l[h],r?r[h]:1),a[u*e+n]=E(c)}a[u*e+n+1]=a[u*e+n]}for(let u=0;u<e;u++)a[u]=a[e+u]=a[2*e+u],a[(i-1)*e+u]=a[(i-2)*e+u];return s.updateStatistics(),s}(t));const{pixels:l,mask:a,bandMasks:r,pixelType:u}=t,c=t.width,n=t.height,h=z.Z.getPixelArrayConstructor(u),y=l.length,{width:f,height:m}=s;let p=!1;for(let F=0;F<e.length;F+=3)-1===e[F]&&-1===e[F+1]&&-1===e[F+2]&&(p=!0);const{offsets_x:M,offsets_y:_,offsets_xi:P,offsets_yi:V,gridWidth:v}=A({width:c,height:n},s,e,i,"majority"===o?.5:0);let U;const L=(F,q,ht,ot)=>{const lt=F instanceof Float32Array||F instanceof Float64Array?0:.5;for(let gt=0;gt<m;gt++){U=gt*v;for(let it=0;it<f;it++){if(M[U]<0||_[U]<0)F[gt*f+it]=0;else if(ot)F[gt*f+it]=q[P[U]+V[U]*c];else{const st=Math.floor(M[U]),wt=Math.floor(_[U]),Mt=Math.ceil(M[U]),At=Math.ceil(_[U]),_t=M[U]-st,vt=_[U]-wt;F[gt*f+it]=!ht||ht[st+wt*c]&&ht[Mt+wt*c]&&ht[st+At*c]&&ht[Mt+At*c]?(1-vt)*((1-_t)*q[st+wt*c]+_t*q[Mt+wt*c])+vt*((1-_t)*q[st+At*c]+_t*q[Mt+At*c])+lt:q[P[U]+V[U]*c]}U++}}},B=[];let K;const Q=r?.length===y,j=[];for(let F=0;F<y;F++){if(Q){const q=new Uint8Array(f*m);L(q,r[F],r[F],!0),j.push(q)}K=new h(f*m),L(K,l[F],Q?r[F]:a,"nearest"===o||"majority"===o),B.push(K)}const H=new z.Z({width:f,height:m,pixelType:u,pixels:B,bandMasks:Q?j:void 0});if(null!=a)H.mask=new Uint8Array(f*m),L(H.mask,a,a,!0);else if(p){H.mask=new Uint8Array(f*m);for(let F=0;F<f*m;F++)H.mask[F]=M[F]<0||_[F]<0?0:1}return H.updateStatistics(),H}},89479:(bt,kt,tt)=>{tt.d(kt,{BH:()=>C,K:()=>E,KC:()=>dt,NL:()=>pt,QI:()=>T,Tg:()=>rt,Yx:()=>yt,nb:()=>R,wF:()=>D,xQ:()=>nt});var z=tt(84303),xt=tt(8868),ct=tt(98797);const ut=new Map;ut.set("meter-per-second",1),ut.set("kilometer-per-hour",.277778),ut.set("knots",.514444),ut.set("feet-per-second",.3048),ut.set("mile-per-hour",.44704);const ft=180/Math.PI,W=5,pt=new z.X({esriMetersPerSecond:"meter-per-second",esriKilometersPerHour:"kilometer-per-hour",esriKnots:"knots",esriFeetPerSecond:"feet-per-second",esriMilesPerHour:"mile-per-hour"});function yt(d,k){return ut.get(d)/ut.get(k)||1}function mt(d){return(450-d)%360}function rt(d,k="geographic"){const[w,A]=d,g=Math.sqrt(w*w+A*A);let x=Math.atan2(A,w)*ft;return x=(360+x)%360,"geographic"===k&&(x=mt(x)),[g,x]}function at(d,k="geographic"){let w=d[1];"geographic"===k&&(w=mt(w)),w%=360;const A=d[0];return[A*Math.cos(w/ft),A*Math.sin(w/ft)]}function nt(d,k,w,A="geographic"){if(!(0,ct.nk)(d)||null==w)return d;const g="vector-magdir"===k?d.clone():dt(d,k),x=g.pixels[1];for(let t=0;t<x.length;t++)x[t]="geographic"===A?(x[t]+w[t]+270)%360:(x[t]+360-w[t])%360;return"vector-magdir"===k?g:dt(g,"vector-magdir")}function dt(d,k,w="geographic",A=1){if(!(0,ct.nk)(d))return d;const{pixels:g,width:x,height:t}=d,s=x*t,e=g[0],i=g[1],o=d.pixelType.startsWith("f")?d.pixelType:"f32",l=xt.Z.createEmptyBand(o,s),a=xt.Z.createEmptyBand(o,s);let r=0;for(let c=0;c<t;c++)for(let n=0;n<x;n++)"vector-uv"===k?([l[r],a[r]]=rt([e[r],i[r]],w),l[r]*=A):([l[r],a[r]]=at([e[r],i[r]],w),l[r]*=A,a[r]*=A),r++;const u=new xt.Z({pixelType:o,width:d.width,height:d.height,mask:d.mask,validPixelCount:d.validPixelCount,maskIsAlpha:d.maskIsAlpha,pixels:[l,a]});return u.updateStatistics(),u}function T(d,k,w=1){if(1===w||!(0,ct.nk)(d))return d;const A=d.clone(),{pixels:g,width:x,height:t}=A,s=g[0],e=g[1];let i=0;for(let o=0;o<t;o++)for(let l=0;l<x;l++)"vector-uv"===k?(s[i]*=w,e[i]*=w):s[i]*=w,i++;return A.updateStatistics(),A}function C(d,k,w,A,g){if(null==g||!g.spatialReference.equals(d.spatialReference))return{extent:d,width:Math.round(k/A),height:Math.round(w/A),resolution:d.width/k};const x=g.xmin,t=g.ymax,s=(d.xmax-d.xmin)/k*A,e=(d.ymax-d.ymin)/w*A,i=(s+e)/2;return d.xmin=x+Math.floor((d.xmin-x)/s)*s,d.xmax=x+Math.ceil((d.xmax-x)/s)*s,d.ymin=t+Math.floor((d.ymin-t)/e)*e,d.ymax=t+Math.ceil((d.ymax-t)/e)*e,{extent:d,width:Math.round(d.width/s),height:Math.round(d.height/e),resolution:i}}const G=J(0,0,0);function J(d=0,k=0,w=Math.PI,A=!0){A&&(w=(2*Math.PI-w)%(2*Math.PI));const g=A?-1:1,x=13*g,t=-7*g,s=-2*g,e=-16*g,i=21.75,[o,l]=O(0,k+x,w,i),[a,r]=O(d-5.5,k+t,w,i),[u,c]=O(d+5.5,k+t,w,i),[n,h]=O(d-1.5,k+s,w,i),[y,f]=O(d+1.5,k+s,w,i),[m,p]=O(d-1.5,k+e,w,i),[M,_]=O(d+1.5,k+e,w,i);return[o,l,a,r,n,h,y,f,u,c,m,p,M,_]}function X(d=0,k=Math.PI,w=!0){w&&(k=(2*Math.PI-k)%(2*Math.PI));const g=w?-1:1,x=5*g,t=20*g,s=25*g,e=45,r=2*g,u=w?1:-1,c=5*u;let[n,h]=[0+c,0-t],[y,f]=[n+2*u,h],[m,p]=[y-0*u,f+r],[M,_]=[0-c,0-s],[P,V]=[M+0*u,_-r],v=Math.ceil(d/W),U=Math.floor(v/10);v-=8*U;const L=[],B=[];for(let gt=0;gt<v/2;gt++,U--){U<=0&&v%2==1&&gt===(v-1)/2&&(M=0,P=M+0*u,_=(_+h)/2,V=_-r);const[it,st]=O(M,_,k,e);if(U>0){const[wt,Mt]=O(y,_,k,e),[At,_t]=O(n,h,k,e);L.push(wt),L.push(Mt),L.push(it),L.push(st),L.push(At),L.push(_t)}else{const[wt,Mt]=O(y,f,k,e),[At,_t]=O(m,p,k,e),[vt,Pt]=O(P,V,k,e);B.push(it),B.push(st),B.push(vt),B.push(Pt),B.push(At),B.push(_t),B.push(wt),B.push(Mt)}_+=x,h+=x,f+=x,p+=x,V+=x}const[K,Q]=O(0+c,0+t,k,e),j=7*u,[H,F]=O(0+j,0+t,k,e),[q,ht]=O(0+c,0-s,k,e),[ot,lt]=O(0+j,0-s,k,e);return{pennants:L,barbs:B,shaft:[K,Q,H,F,q,ht,ot,lt]}}function O(d,k,w,A=1){const g=Math.sqrt(d*d+k*k)/A,x=(2*Math.PI+Math.atan2(k,d))%(2*Math.PI);return[g,(2*Math.PI+x-w)%(2*Math.PI)]}const S=[0,1,3,6,10,16,21,27,33,40,47,55,63],Y=[0,.5,1,1.5,2],Z=[0,.25,.5,1,1.5,2,2.5,3,3.5,4];function $(d,k,w,A){const g=yt(A||"knots",w);let x;for(x=1;x<k.length;x++)if(x===k.length-1){if(d<k[x]*g)break}else if(d<=k[x]*g)break;return Math.min(x-1,k.length-2)}function et(d,k,w,A,g){let x=0;switch(k){case"beaufort_kn":x=$(d,S,"knots",w);break;case"beaufort_km":x=$(d,S,"kilometer-per-hour",w);break;case"beaufort_ft":x=$(d,S,"feet-per-second",w);break;case"beaufort_m":x=$(d,S,"meter-per-second",w);break;case"classified_arrow":x=$(d,g??[],A,w);break;case"ocean_current_m":x=$(d,Y,"meter-per-second",w);break;case"ocean_current_kn":x=$(d,Z,"knots",w)}return x}const I=[];function E(d,k){let A=0,g=0;const{width:x,height:t,mask:s}=d,e=d.pixels[0],i=[],o=[],l=yt(pt.fromJSON(k.inputUnit),"knots"),a="wind_speed"===k.style?W:Number.MAX_VALUE;for(let r=0;r<t;r++)for(let u=0;u<x;u++){const c=e[r*x+u]*l;if((!s||s[r*x+u])&&c<a){for(let h=0;h<4;h++)i[A++]=(u+.5)/x,i[A++]=(r+.5)/t,i[A++]=h<2?-.5:.5,i[A++]=h%2==0?-.5:.5,i[A++]=0,i[A++]=c;const n=4*(A/24-1);o[g++]=n,o[g++]=n+1,o[g++]=n+2,o[g++]=n+1,o[g++]=n+2,o[g++]=n+3}}return{vertexData:new Float32Array(i),indexData:new Uint32Array(o)}}function D(d,k){return"simple_scalar"===k.style?E(d,k):"wind_speed"===k.style?function b(d,k){if(0===I.length)for(let r=0;r<30;r++)I.push(X(5*r,0,!k.invertDirection));const w=yt(pt.fromJSON(k.inputUnit),"knots"),{width:A,height:g,mask:x}=d,t=d.pixels[0],s=d.pixels[1],i=[],o=[];let l=0,a=0;for(let r=0;r<g;r++)for(let u=0;u<A;u++){const c=r*A+u,n=t[c]*w;if((!x||x[r*A+u])&&n>=W){const h=(s[c]+360)%360/180*Math.PI,{pennants:y,barbs:f,shaft:m}=I[Math.min(Math.floor(n/5),29)];if(y.length+f.length===0)continue;let p=i.length/6;const M=(u+.5)/A,_=(r+.5)/g;for(let P=0;P<y.length;P+=2)i[l++]=M,i[l++]=_,i[l++]=y[P],i[l++]=y[P+1]+h,i[l++]=0,i[l++]=n;for(let P=0;P<f.length;P+=2)i[l++]=M,i[l++]=_,i[l++]=f[P],i[l++]=f[P+1]+h,i[l++]=0,i[l++]=n;for(let P=0;P<m.length;P+=2)i[l++]=M,i[l++]=_,i[l++]=m[P],i[l++]=m[P+1]+h,i[l++]=0,i[l++]=n;for(let P=0;P<y.length/6;P++)o[a++]=p,o[a++]=p+1,o[a++]=p+2,p+=3;for(let P=0;P<f.length/8;P++)o[a++]=p,o[a++]=p+1,o[a++]=p+2,o[a++]=p+1,o[a++]=p+2,o[a++]=p+3,p+=4;o[a++]=p+0,o[a++]=p+1,o[a++]=p+2,o[a++]=p+1,o[a++]=p+3,o[a++]=p+2,p+=4}}return{vertexData:new Float32Array(i),indexData:new Uint32Array(o)}}(d,k):function N(d,k){const{style:w,inputUnit:A,outputUnit:g,breakValues:x}=k,t=pt.fromJSON(A),s=pt.fromJSON(g);let o=0,l=0;const{width:a,height:r,mask:u}=d,c=d.pixels[0],n=d.pixels[1],h=null!=u?u.filter(p=>p>0).length:a*r,y=new Float32Array(42*h),f=new Uint32Array(15*h),m=k.invertDirection?J(0,0,0,!1):G;for(let p=0;p<r;p++)for(let M=0;M<a;M++){const _=p*a+M;if(!u||u[p*a+M]){const P=(n[_]+360)%360/180*Math.PI,V=et(c[_],w,t,s,x);for(let U=0;U<m.length;U+=2)y[o++]=(M+.5)/a,y[o++]=(p+.5)/r,y[o++]=m[U],y[o++]=m[U+1]+P,y[o++]=V,y[o++]=c[_];const v=7*(o/42-1);f[l++]=v,f[l++]=v+1,f[l++]=v+2,f[l++]=v+0,f[l++]=v+4,f[l++]=v+3,f[l++]=v+0,f[l++]=v+2,f[l++]=v+3,f[l++]=v+2,f[l++]=v+5,f[l++]=v+3,f[l++]=v+5,f[l++]=v+6,f[l++]=v+3}}return{vertexData:y,indexData:f}}(d,k)}function R(d,k,w,A=[0,0],g=.5){const{width:x,height:t,mask:s}=d,[e,i]=d.pixels,[o,l]=A,a=Math.round((x-o)/w),r=Math.round((t-l)/w),u=a*r,c=new Float32Array(u),n=new Float32Array(u),h=new Uint8Array(u),y="vector-uv"===k;for(let m=0;m<r;m++)for(let p=0;p<a;p++){let M=0;const _=m*a+p,P=Math.max(0,m*w+l),V=Math.max(0,p*w+o),v=Math.min(t,P+w),U=Math.min(x,V+w);for(let L=P;L<v;L++)for(let B=V;B<U;B++){const K=L*x+B;if(!s||s[K]){M++;const Q=y?[e[K],i[K]]:[e[K],(360+i[K])%360],[j,H]=y?Q:at(Q);c[_]+=j,n[_]+=H}}if(M>=(v-P)*(U-V)*(1-g)){h[_]=1;const[L,B]=rt([c[_]/M,n[_]/M]);c[_]=L,n[_]=B}else h[_]=0,c[_]=0,n[_]=0}const f=new xt.Z({width:a,height:r,pixels:[c,n],mask:h});return f.updateStatistics(),f}},74155:(bt,kt,tt)=>{tt.d(kt,{GE:()=>nt,KK:()=>Z});var z=tt(15861),ct=(tt(2189),tt(14007)),ut=tt(4703),ft=tt(55117),W=tt(79412),pt=tt(65311),yt=tt(33721),mt=tt(26894);const rt=ut.Z.getLogger("esri.views.2d.engine.flow.dataUtils"),at=10;function nt(I,b,E,D){return dt.apply(this,arguments)}function dt(){return(dt=(0,z.Z)(function*(I,b,E,D){const R=performance.now(),d=function T(I,b){const E=function J(I,b,E,D){if(0===D)return I;const R=Math.round(3*D),d=new Array(2*R+1);let k=0;for(let g=-R;g<=R;g++){const x=Math.exp(-g*g/(D*D));d[g+R]=x,k+=x}for(let g=-R;g<=R;g++)d[g+R]/=k;const w=new Float32Array(I.length);for(let g=0;g<E;g++)for(let x=0;x<b;x++){let t=0,s=0;for(let e=-R;e<=R;e++){if(x+e<0||x+e>=b)continue;const i=d[e+R];t+=i*I[2*(g*b+(x+e))],s+=i*I[2*(g*b+(x+e))+1]}w[2*(g*b+x)]=t,w[2*(g*b+x)+1]=s}const A=new Float32Array(I.length);for(let g=0;g<b;g++)for(let x=0;x<E;x++){let t=0,s=0;for(let e=-R;e<=R;e++){if(x+e<0||x+e>=E)continue;const i=d[e+R];t+=i*w[2*((x+e)*b+g)],s+=i*w[2*((x+e)*b+g)+1]}A[2*(x*b+g)]=t,A[2*(x*b+g)+1]=s}return A}(b.data,b.width,b.height,I.smoothing);return I.interpolate?(D,R)=>{const d=Math.floor(D),k=Math.floor(R);if(d<0||d>=b.width)return[0,0];if(k<0||k>=b.height)return[0,0];const w=D-d,A=R-k,t=d<b.width-1?d+1:d,s=k<b.height-1?k+1:k;return[(E[2*(k*b.width+d)]*(1-A)+E[2*(s*b.width+d)]*A)*(1-w)+(E[2*(k*b.width+t)]*(1-A)+E[2*(s*b.width+t)]*A)*w,(E[2*(k*b.width+d)+1]*(1-A)+E[2*(s*b.width+d)+1]*A)*(1-w)+(E[2*(k*b.width+t)+1]*(1-A)+E[2*(s*b.width+t)+1]*A)*w]}:(D,R)=>{const d=Math.round(D),k=Math.round(R);return d<0||d>=b.width||k<0||k>=b.height?[0,0]:[E[2*(k*b.width+d)],E[2*(k*b.width+d)+1]]}}(b,E),k=performance.now(),w=function G(I,b,E,D){const R=[],d=new pt.Z,k=1/Math.max(I.lineCollisionWidth,1),w=Math.round(E*k),A=Math.round(D*k),g=new Int32Array(w*A);for(let t=0;t<g.length;t++)g[t]=-1;const x=[];for(let t=0;t<D;t+=I.lineSpacing)for(let s=0;s<E;s+=I.lineSpacing)x.push({x:s,y:t,sort:d.getFloat()});x.sort((t,s)=>t.sort-s.sort);for(const{x:t,y:s}of x)if(d.getFloat()<I.density){const e=C(I,b,t,s,R.length,g,w,A,k);if(e.length<2)continue;R.push(e)}return R}(b,d,E.width,E.height),A=performance.now(),g=function X(I,b){const E=new pt.Z,D=I.reduce((A,g)=>A+g.length,0),R=new Float32Array(4*D),d=new Array(I.length);let k=0,w=0;for(const A of I){const g=k;for(const x of A)R[4*k]=x.x,R[4*k+1]=x.y,R[4*k+2]=x.t,R[4*k+3]=x.speed,k++;d[w++]={startVertex:g,numberOfVertices:A.length,totalTime:A[A.length-1].t,timeSeed:b?E.getFloat():0}}return{lineVertices:R,lineDescriptors:d}}(w,!0),x=performance.now(),t="Streamlines"===I?function O(I,b){const{lineVertices:D,lineDescriptors:R}=I;let d=0,k=0;for(const e of R)d+=2*e.numberOfVertices,k+=6*(e.numberOfVertices-1);const w=new Float32Array(9*d),A=new Uint32Array(k);let g=0,x=0;function s(e,i,o,l,a,r,u,c){const n=9*g;let h=0;w[n+h++]=e,w[n+h++]=i,w[n+h++]=1,w[n+h++]=o,w[n+h++]=r,w[n+h++]=u,w[n+h++]=l/2,w[n+h++]=a/2,w[n+h++]=c,g++,w[n+h++]=e,w[n+h++]=i,w[n+h++]=-1,w[n+h++]=o,w[n+h++]=r,w[n+h++]=u,w[n+h++]=-l/2,w[n+h++]=-a/2,w[n+h++]=c,g++}for(const e of R){const{totalTime:i,timeSeed:o}=e;let l=null,a=null,r=null,u=null,c=null,n=null;for(let h=0;h<e.numberOfVertices;h++){const y=D[4*(e.startVertex+h)],f=D[4*(e.startVertex+h)+1],m=D[4*(e.startVertex+h)+2],p=D[4*(e.startVertex+h)+3];let M=null,_=null,P=null,V=null;if(h>0){M=y-l,_=f-a;const v=Math.sqrt(M*M+_*_);if(M/=v,_/=v,h>1){let U=M+c,L=_+n;const B=Math.sqrt(U*U+L*L);U/=B,L/=B;const K=Math.min(1/(U*M+L*_),b);U*=K,L*=K,P=-L,V=U}else P=-_,V=M;null!==P&&null!==V&&(s(l,a,r,P,V,i,o,p),A[x++]=g-2,A[x++]=g,A[x++]=g-1,A[x++]=g,A[x++]=g+1,A[x++]=g-1)}l=y,a=f,r=m,c=M,n=_,u=p}s(l,a,r,-n,c,i,o,u)}return{vertexData:w,indexData:A}}(g,at):function S(I){const{lineVertices:R,lineDescriptors:d}=I;let k=0,w=0;for(const v of d){const U=v.numberOfVertices-1;k+=4*U*2,w+=6*U*2}const A=new Float32Array(16*k),g=new Uint32Array(w);let x,t,s,e,i,o,l,a,r,u,c,n,h,y,f=0,m=0;function _(v,U){let L=r+c,B=u+n;const K=Math.sqrt(L*L+B*B);L/=K,B/=K;const Q=r*L+u*B;L/=Q,B/=Q;let j=c+h,H=n+y;const F=Math.sqrt(j*j+H*H);j/=F,H/=F;const q=c*j+n*H;j/=q,H/=q,function M(v,U,L,B,K,Q,j,H,F,q,ht,ot,lt,gt){const it=16*f;let st=0;for(const wt of[1,2])for(const Mt of[1,2,3,4])A[it+st++]=v,A[it+st++]=U,A[it+st++]=L,A[it+st++]=B,A[it+st++]=j,A[it+st++]=H,A[it+st++]=F,A[it+st++]=q,A[it+st++]=wt,A[it+st++]=Mt,A[it+st++]=lt,A[it+st++]=gt,A[it+st++]=K/2,A[it+st++]=Q/2,A[it+st++]=ht/2,A[it+st++]=ot/2,f++}(x,t,s,e,-B,L,i,o,l,a,-H,j,v,U),function p(){g[m++]=f-8,g[m++]=f-7,g[m++]=f-6,g[m++]=f-7,g[m++]=f-5,g[m++]=f-6,g[m++]=f-4,g[m++]=f-3,g[m++]=f-2,g[m++]=f-3,g[m++]=f-1,g[m++]=f-2}()}function P(v,U,L,B,K,Q){if(r=c,u=n,c=h,n=y,null==r&&null==u&&(r=c,u=n),null!=i&&null!=o){h=v-i,y=U-o;const j=Math.sqrt(h*h+y*y);h/=j,y/=j}null!=r&&null!=u&&_(K,Q),x=i,t=o,s=l,e=a,i=v,o=U,l=L,a=B}function V(v,U){r=c,u=n,c=h,n=y,null==r&&null==u&&(r=c,u=n),null!=r&&null!=u&&_(v,U)}for(const v of d){x=null,t=null,s=null,e=null,i=null,o=null,l=null,a=null,r=null,u=null,c=null,n=null,h=null,y=null;const{totalTime:U,timeSeed:L}=v;for(let B=0;B<v.numberOfVertices;B++)P(R[4*(v.startVertex+B)],R[4*(v.startVertex+B)+1],R[4*(v.startVertex+B)+2],R[4*(v.startVertex+B)+3],U,L);V(U,L)}return{vertexData:A,indexData:g}}(g),s=performance.now();return(0,ct.Z)("esri-2d-profiler")&&(rt.info("I.1","_createFlowFieldFromData (ms)",Math.round(k-R)),rt.info("I.2","_getStreamlines (ms)",Math.round(A-k)),rt.info("I.3","createAnimatedLinesData (ms)",Math.round(x-A)),rt.info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(s-x)),rt.info("I.5","createFlowMesh (ms)",Math.round(s-R)),rt.info("I.6","Mesh size (bytes)",t.vertexData.buffer.byteLength+t.indexData.buffer.byteLength)),yield Promise.resolve(),(0,W.k_)(D),t})).apply(this,arguments)}function C(I,b,E,D,R,d,k,w,A){const g=[];let x=E,t=D,s=0,[e,i]=b(x,t);e*=I.velocityScale,i*=I.velocityScale;const o=Math.sqrt(e*e+i*i);let l,a;g.push({x,y:t,t:s,speed:o});for(let r=0;r<I.verticesPerLine;r++){let[u,c]=b(x,t);u*=I.velocityScale,c*=I.velocityScale;const n=Math.sqrt(u*u+c*c);if(n<I.minSpeedThreshold)return g;const h=u/n,y=c/n;if(x+=h*I.segmentLength,t+=y*I.segmentLength,s+=I.segmentLength/n,Math.acos(h*l+y*a)>I.maxTurnAngle)return g;if(I.collisions){const f=Math.round(x*A),m=Math.round(t*A);if(f<0||f>k-1||m<0||m>w-1)return g;const p=d[m*k+f];if(-1!==p&&p!==R)return g;d[m*k+f]=R}g.push({x,y:t,t:s,speed:n}),l=h,a=y}return g}function Y(I,b){const E=b.pixels,{width:D,height:R}=b,d=new Float32Array(D*R*2),k=b.mask||new Uint8Array(D*R*2);if(b.mask||k.fill(255),"vector-uv"===I)for(let w=0;w<D*R;w++)d[2*w]=E[0][w],d[2*w+1]=-E[1][w];else if("vector-magdir"===I)for(let w=0;w<D*R;w++){const A=E[0][w],g=(0,ft.Vl)(E[1][w]),x=Math.cos(g-Math.PI/2),t=Math.sin(g-Math.PI/2);d[2*w]=x*A,d[2*w+1]=t*A}return{data:d,mask:k,width:D,height:R}}function Z(I,b,E,D,R,d){return $.apply(this,arguments)}function $(){return($=(0,z.Z)(function*(I,b,E,D,R,d){const k=performance.now(),w=(0,yt.C5)(b.spatialReference);if(!w){const c=yield et(I,b,E,D,R,d);return(0,ct.Z)("esri-2d-profiler")&&rt.info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-k)),(0,ct.Z)("esri-2d-profiler")&&rt.info("I.9","Number of parts",1),c}const[A,g]=w.valid,t=Math.ceil(b.width/(g-A)),s=b.width/t,e=Math.round(E/t);let i=b.xmin;const o=[],l=performance.now();for(let c=0;c<t;c++){const n=new mt.Z({xmin:i,xmax:i+s,ymin:b.ymin,ymax:b.ymax,spatialReference:b.spatialReference});o.push(et(I,n,e,D,R,d)),i+=s}const a=yield Promise.all(o);(0,ct.Z)("esri-2d-profiler")&&rt.info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-l)),(0,ct.Z)("esri-2d-profiler")&&rt.info("I.9","Number of parts",a.length);const r={data:new Float32Array(E*D*2),mask:new Uint8Array(E*D),width:E,height:D};let u=0;for(const c of a){for(let n=0;n<c.height;n++)for(let h=0;h<c.width;h++)u+h>=E||(r.data[2*(n*E+u+h)]=c.data[2*(n*c.width+h)],r.data[2*(n*E+u+h)+1]=c.data[2*(n*c.width+h)+1],r.mask[n*E+u+h]=c.mask[n*c.width+h]);u+=c.width}return(0,ct.Z)("esri-2d-profiler")&&rt.info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-k)),r})).apply(this,arguments)}function et(I,b,E,D,R,d){return N.apply(this,arguments)}function N(){return(N=(0,z.Z)(function*(I,b,E,D,R,d){const k={requestProjectedLocalDirections:!0,signal:d};if(null!=R&&(k.timeExtent=R),"imagery"===I.type){yield I.load({signal:d});const g=I.rasterInfo.dataType,x=yield I.fetchImage(b,E,D,k);return null==x?.pixelData?.pixelBlock?{data:new Float32Array(E*D*2),mask:new Uint8Array(E*D),width:E,height:D}:Y(g,x.pixelData.pixelBlock)}yield I.load({signal:d});const w=I.rasterInfo.dataType,A=yield I.fetchPixels(b,E,D,k);return null==A?.pixelBlock?{data:new Float32Array(E*D*2),mask:new Uint8Array(E*D),width:E,height:D}:Y(w,A.pixelBlock)})).apply(this,arguments)}}}]);