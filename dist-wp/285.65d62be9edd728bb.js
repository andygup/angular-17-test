"use strict";(self.webpackChunkangular_17_test=self.webpackChunkangular_17_test||[]).push([[285],{93530:(U,I,b)=>{function Y(){return[1,0,0,0,1,0,0,0,1]}function A(M,r,c,m,d,v,s,_,h){return[M,r,c,m,d,v,s,_,h]}function T(M,r){return new Float64Array(M,r,9)}b.d(I,{a:()=>Y,c:()=>T,f:()=>A}),Object.freeze(Object.defineProperty({__proto__:null,clone:function E(M){return[M[0],M[1],M[2],M[3],M[4],M[5],M[6],M[7],M[8]]},create:Y,createView:T,fromValues:A},Symbol.toStringTag,{value:"Module"}))},89568:(U,I,b)=>{function Y(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function E(r){return[r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11],r[12],r[13],r[14],r[15]]}function T(r,c){return new Float64Array(r,c,16)}b.d(I,{I:()=>S,a:()=>Y,b:()=>E,c:()=>T});const S=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];Object.freeze(Object.defineProperty({__proto__:null,IDENTITY:S,clone:E,create:Y,createView:T,fromValues:function A(r,c,m,d,v,s,_,h,p,P,B,X,x,y,O,D){return[r,c,m,d,v,s,_,h,p,P,B,X,x,y,O,D]}},Symbol.toStringTag,{value:"Module"}))},7577:(U,I,b)=>{function Y(){return[0,0,0,1]}function E(r){return[r[0],r[1],r[2],r[3]]}function T(r,c){return new Float64Array(r,c,4)}b.d(I,{I:()=>S,a:()=>Y,b:()=>E,c:()=>T});const S=[0,0,0,1];Object.freeze(Object.defineProperty({__proto__:null,IDENTITY:S,clone:E,create:Y,createView:T,fromValues:function A(r,c,m,d){return[r,c,m,d]}},Symbol.toStringTag,{value:"Module"}))},43548:(U,I,b)=>{b.d(I,{a:()=>S,b:()=>T,c:()=>E,d:()=>c,e:()=>M,n:()=>m,s:()=>r,t:()=>A});var Y=b(58466);function E(s,_,h){A(s.typedBuffer,_.typedBuffer,h,s.typedBufferStride,_.typedBufferStride)}function A(s,_,h,p=3,P=p){if(s.length/p!==Math.ceil(_.length/P))return Y.c.error("source and destination buffers need to have the same number of elements"),s;const B=s.length/p,X=h[0],x=h[1],y=h[2],O=h[4],D=h[5],R=h[6],C=h[8],a=h[9],t=h[10],e=h[12],n=h[13],i=h[14];let o=0,l=0;for(let u=0;u<B;u++){const f=_[o],w=_[o+1],g=_[o+2];s[l]=X*f+O*w+C*g+e,s[l+1]=x*f+D*w+a*g+n,s[l+2]=y*f+R*w+t*g+i,o+=P,l+=p}return s}function T(s,_,h){S(s.typedBuffer,_.typedBuffer,h,s.typedBufferStride,_.typedBufferStride)}function S(s,_,h,p=3,P=p){if(s.length/p!==Math.ceil(_.length/P))return void Y.c.error("source and destination buffers need to have the same number of elements");const B=s.length/p,X=h[0],x=h[1],y=h[2],O=h[3],D=h[4],R=h[5],C=h[6],a=h[7],t=h[8];let e=0,n=0;for(let i=0;i<B;i++){const o=_[e],l=_[e+1],u=_[e+2];s[n]=X*o+O*l+C*u,s[n+1]=x*o+D*l+a*u,s[n+2]=y*o+R*l+t*u,e+=P,n+=p}}function M(s,_,h){r(s.typedBuffer,_,h,s.typedBufferStride)}function r(s,_,h,p=3){const P=Math.min(s.length/p,_.count),B=_.typedBuffer,X=_.typedBufferStride;let x=0,y=0;for(let O=0;O<P;O++)s[y]=h*B[x],s[y+1]=h*B[x+1],s[y+2]=h*B[x+2],x+=X,y+=p}function c(s,_){m(s.typedBuffer,_.typedBuffer,s.typedBufferStride,_.typedBufferStride)}function m(s,_,h=3,p=h){const P=Math.min(s.length/h,_.length/p);let B=0,X=0;for(let x=0;x<P;x++){const y=_[B],O=_[B+1],D=_[B+2],R=y*y+O*O+D*D;if(R>0){const C=1/Math.sqrt(R);s[X]=C*y,s[X+1]=C*O,s[X+2]=C*D}B+=p,X+=h}}Object.freeze(Object.defineProperty({__proto__:null,normalize:m,normalizeView:c,scale:r,scaleView:M,shiftRight:function d(s,_,h){const p=Math.min(s.count,_.count),P=s.typedBuffer,B=s.typedBufferStride,X=_.typedBuffer,x=_.typedBufferStride;let y=0,O=0;for(let D=0;D<p;D++)P[O]=X[y]>>h,P[O+1]=X[y+1]>>h,P[O+2]=X[y+2]>>h,y+=x,O+=B},transformMat3:S,transformMat3View:T,transformMat4:A,transformMat4View:E},Symbol.toStringTag,{value:"Module"}))},26540:(U,I,b)=>{b.d(I,{Q:()=>T});var Y=b(57678),E=b(43029),A=b(4758);class T{constructor(t=9,e){this._compareMinX=c,this._compareMinY=m,this._toBBox=n=>n,this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),e&&("function"==typeof e?this._toBBox=e:this._initFormat(e)),this.clear()}destroy(){this.clear(),B.prune(),X.prune(),x.prune(),y.prune()}all(t){this._all(this._data,t)}search(t,e){let n=this._data;const i=this._toBBox;if(p(t,n))for(B.clear();n;){for(let o=0,l=n.children.length;o<l;o++){const u=n.children[o],f=n.leaf?i(u):u;p(t,f)&&(n.leaf?e(u):h(t,f)?this._all(u,e):B.push(u))}n=B.pop()}}collides(t){let e=this._data;const n=this._toBBox;if(!p(t,e))return!1;for(B.clear();e;){for(let i=0,o=e.children.length;i<o;i++){const l=e.children[i],u=e.leaf?n(l):l;if(p(t,u)){if(e.leaf||h(t,u))return!0;B.push(l)}}e=B.pop()}return!1}load(t){if(!t.length)return this;if(t.length<this._minEntries){for(let n=0,i=t.length;n<i;n++)this.insert(t[n]);return this}let e=this._build(t.slice(0,t.length),0,t.length-1,0);if(this._data.children.length)if(this._data.height===e.height)this._splitRoot(this._data,e);else{if(this._data.height<e.height){const n=this._data;this._data=e,e=n}this._insert(e,this._data.height-e.height-1,!0)}else this._data=e;return this}insert(t){return t&&this._insert(t,this._data.height-1),this}clear(){return this._data=new R([]),this}remove(t){if(!t)return this;let e,n=this._data,i=null,o=0,l=!1;const u=this._toBBox(t);for(x.clear(),y.clear();n||x.length>0;){if(n||(n=x.pop(),i=x.data[x.length-1],o=y.pop()??0,l=!0),n.leaf&&(e=(0,Y.cq)(n.children,t,n.children.length,n.indexHint),-1!==e))return n.children.splice(e,1),x.push(n),this._condense(x),this;l||n.leaf||!h(n,u)?i?(o++,n=i.children[o],l=!1):n=null:(x.push(n),y.push(o),o=0,i=n,n=n.children[0])}return this}toJSON(){return this._data}fromJSON(t){return this._data=t,this}_all(t,e){let n=t;for(X.clear();n;){if(!0===n.leaf)for(const i of n.children)e(i);else X.pushArray(n.children);n=X.pop()??null}}_build(t,e,n,i){const o=n-e+1;let l=this._maxEntries;if(o<=l){const g=new R(t.slice(e,n+1));return S(g,this._toBBox),g}i||(i=Math.ceil(Math.log(o)/Math.log(l)),l=Math.ceil(o/l**(i-1)));const u=new C([]);u.height=i;const f=Math.ceil(o/l),w=f*Math.ceil(Math.sqrt(l));P(t,e,n,w,this._compareMinX);for(let g=e;g<=n;g+=w){const j=Math.min(g+w-1,n);P(t,g,j,f,this._compareMinY);for(let L=g;L<=j;L+=f){const k=Math.min(L+f-1,j);u.children.push(this._build(t,L,k,i-1))}}return S(u,this._toBBox),u}_chooseSubtree(t,e,n,i){for(;i.push(e),!0!==e.leaf&&i.length-1!==n;){let o,l=1/0,u=1/0;for(let f=0,w=e.children.length;f<w;f++){const g=e.children[f],j=d(g),L=s(t,g)-j;L<u?(u=L,l=j<l?j:l,o=g):L===u&&j<l&&(l=j,o=g)}e=o||e.children[0]}return e}_insert(t,e,n){const o=n?t:(0,this._toBBox)(t);x.clear();const l=this._chooseSubtree(o,this._data,e,x);for(l.children.push(t),r(l,o);e>=0&&x.data[e].children.length>this._maxEntries;)this._split(x,e),e--;this._adjustParentBBoxes(o,x,e)}_split(t,e){const n=t.data[e],i=n.children.length,o=this._minEntries;this._chooseSplitAxis(n,o,i);const l=this._chooseSplitIndex(n,o,i);if(!l)return void console.log("  Error: assertion failed at PooledRBush._split: no valid split index");const u=n.children.splice(l,n.children.length-l),f=n.leaf?new R(u):new C(u);f.height=n.height,S(n,this._toBBox),S(f,this._toBBox),e?t.data[e-1].children.push(f):this._splitRoot(n,f)}_splitRoot(t,e){this._data=new C([t,e]),this._data.height=t.height+1,S(this._data,this._toBBox)}_chooseSplitIndex(t,e,n){let i,o,l;i=o=1/0;for(let u=e;u<=n-e;u++){const f=M(t,0,u,this._toBBox),w=M(t,u,n,this._toBBox),g=_(f,w),j=d(f)+d(w);g<i?(i=g,l=u,o=j<o?j:o):g===i&&j<o&&(o=j,l=u)}return l}_chooseSplitAxis(t,e,n){const i=t.leaf?this._compareMinX:c,o=t.leaf?this._compareMinY:m;this._allDistMargin(t,e,n,i)<this._allDistMargin(t,e,n,o)&&t.children.sort(i)}_allDistMargin(t,e,n,i){t.children.sort(i);const o=this._toBBox,l=M(t,0,e,o),u=M(t,n-e,n,o);let f=v(l)+v(u);for(let w=e;w<n-e;w++){const g=t.children[w];r(l,t.leaf?o(g):g),f+=v(l)}for(let w=n-e-1;w>=e;w--){const g=t.children[w];r(u,t.leaf?o(g):g),f+=v(u)}return f}_adjustParentBBoxes(t,e,n){for(let i=n;i>=0;i--)r(e.data[i],t)}_condense(t){for(let e=t.length-1;e>=0;e--){const n=t.data[e];if(0===n.children.length)if(e>0){const i=t.data[e-1],o=i.children;o.splice((0,Y.cq)(o,n,o.length,i.indexHint),1)}else this.clear();else S(n,this._toBBox)}}_initFormat(t){const e=["return a"," - b",";"];this._compareMinX=new Function("a","b",e.join(t[0])),this._compareMinY=new Function("a","b",e.join(t[1])),this._toBBox=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}}function S(a,t){M(a,0,a.children.length,t,a)}function M(a,t,e,n,i){i||(i=new R([])),i.minX=1/0,i.minY=1/0,i.maxX=-1/0,i.maxY=-1/0;for(let o,l=t;l<e;l++)o=a.children[l],r(i,a.leaf?n(o):o);return i}function r(a,t){a.minX=Math.min(a.minX,t.minX),a.minY=Math.min(a.minY,t.minY),a.maxX=Math.max(a.maxX,t.maxX),a.maxY=Math.max(a.maxY,t.maxY)}function c(a,t){return a.minX-t.minX}function m(a,t){return a.minY-t.minY}function d(a){return(a.maxX-a.minX)*(a.maxY-a.minY)}function v(a){return a.maxX-a.minX+(a.maxY-a.minY)}function s(a,t){return(Math.max(t.maxX,a.maxX)-Math.min(t.minX,a.minX))*(Math.max(t.maxY,a.maxY)-Math.min(t.minY,a.minY))}function _(a,t){const e=Math.max(a.minX,t.minX),n=Math.max(a.minY,t.minY),i=Math.min(a.maxX,t.maxX),o=Math.min(a.maxY,t.maxY);return Math.max(0,i-e)*Math.max(0,o-n)}function h(a,t){return a.minX<=t.minX&&a.minY<=t.minY&&t.maxX<=a.maxX&&t.maxY<=a.maxY}function p(a,t){return t.minX<=a.maxX&&t.minY<=a.maxY&&t.maxX>=a.minX&&t.maxY>=a.minY}function P(a,t,e,n,i){const o=[t,e];for(;o.length;){const l=o.pop(),u=o.pop();if(l-u<=n)continue;const f=u+Math.ceil((l-u)/n/2)*n;(0,A.q)(a,f,u,l,i),o.push(u,f,f,l)}}const B=new E.Z,X=new E.Z,x=new E.Z,y=new E.Z({deallocator:void 0});class O{constructor(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}}class D extends O{constructor(){super(...arguments),this.height=1,this.indexHint=new Y.SO}}class R extends D{constructor(t){super(),this.children=t,this.leaf=!0}}class C extends D{constructor(t){super(),this.children=t,this.leaf=!1}}},58466:(U,I,b)=>{b.d(I,{c:()=>E});const E=b(4703).Z.getLogger("esri.views.3d.support.buffer.math")},63517:(U,I,b)=>{b.r(I),b.d(I,{default:()=>S});var Y=b(15861),E=b(14007),A=b(26540),T=b(92859);class S{createIndex(c,m){var d=this;return(0,Y.Z)(function*(){const v=new Array;if(!c.vertexAttributes?.position)return new A.Q;const s=d._createMeshData(c),_=null!=m?yield m.invoke("createIndexThread",s,{transferList:v}):d.createIndexThread(s).result;return d._createPooledRBush().fromJSON(_)})()}createIndexThread(c){const m=new Float64Array(c.position),d=this._createPooledRBush();return c.components?this._createIndexComponentsThread(d,m,c.components.map(v=>new Uint32Array(v))):this._createIndexAllThread(d,m)}_createIndexAllThread(c,m){const d=new Array(m.length/9);let v=0;for(let s=0;s<m.length;s+=9)d[v++]=M(m,s,s+3,s+6);return c.load(d),{result:c.toJSON()}}_createIndexComponentsThread(c,m,d){let v=0;for(const h of d)v+=h.length/3;const s=new Array(v);let _=0;for(const h of d)for(let p=0;p<h.length;p+=3)s[_++]=M(m,3*h[p],3*h[p+1],3*h[p+2]);return c.load(s),{result:c.toJSON()}}_createMeshData(c){const m=(c.vertexSpace.isRelative?(0,T.georeferenceApplyTransform)({position:c.vertexAttributes.position,normal:null,tangent:null},c.vertexSpace,c.transform,c.spatialReference).position:c.vertexAttributes.position).buffer;return!c.components||c.components.some(d=>!d.faces)?{position:m}:{position:m,components:c.components.map(d=>d.faces)}}_createPooledRBush(){return new A.Q(9,(0,E.Z)("esri-csp-restrictions")?c=>c:[".minX",".minY",".maxX",".maxY"])}}function M(r,c,m,d){return{minX:Math.min(r[c],r[m],r[d]),maxX:Math.max(r[c],r[m],r[d]),minY:Math.min(r[c+1],r[m+1],r[d+1]),maxY:Math.max(r[c+1],r[m+1],r[d+1]),p0:[r[c],r[c+1],r[c+2]],p1:[r[m],r[m+1],r[m+2]],p2:[r[d],r[d+1],r[d+2]]}}}}]);