import{a as O,c as F,d as m,h as H,j as x}from"./chunk-Z7J4BCLI.js";import{e as o,h as E,m as l,n as C,p as z,q as T,r as A,t as b,v as d,w as c,y as L}from"./chunk-TKTKGUCU.js";import{a as f}from"./chunk-MNLP6AEE.js";import{c as y}from"./chunk-XDTDVCGP.js";import{p as g}from"./chunk-465DRXTW.js";import{A as P,h as M,y as U}from"./chunk-AC62Z3FX.js";import{g as R}from"./chunk-ESDYQQXO.js";var u=g.getLogger("esri.views.webgl.BufferObject"),S=class s{static createIndex(e,t,i){return new s(e,o.ELEMENT_ARRAY_BUFFER,t,i)}static createVertex(e,t,i){return new s(e,o.ARRAY_BUFFER,t,i)}static createUniform(e,t,i){if(e.type!==f.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new s(e,o.UNIFORM_BUFFER,t,i)}static createPixelPack(e,t=A.STREAM_READ,i){if(e.type!==f.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");let r=new s(e,o.PIXEL_PACK_BUFFER,t);return i&&r.setSize(i),r}static createPixelUnpack(e,t=A.STREAM_DRAW,i){if(e.type!==f.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new s(e,o.PIXEL_UNPACK_BUFFER,t,i)}constructor(e,t,i,r){this._context=e,this.bufferType=t,this.usage=i,this._glName=null,this._size=-1,this._indexType=void 0,e.instanceCounter.increment(d.BufferObject,this),this._glName=this._context.gl.createBuffer(),F(this._context.gl),r&&this.setData(r)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteLength(){return this.bufferType===o.ELEMENT_ARRAY_BUFFER?this._indexType===E.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===o.ELEMENT_ARRAY_BUFFER||this.bufferType===o.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(d.BufferObject,this),this._context=null):this._glName&&u.warn("Leaked WebGL buffer object")}setSize(e,t=null){if(e<=0&&u.error("Buffer size needs to be positive!"),this.bufferType===o.ELEMENT_ARRAY_BUFFER&&t!=null)switch(this._indexType=t,t){case E.UNSIGNED_SHORT:e*=2;break;case E.UNSIGNED_INT:e*=4}this._setBufferData(e)}setData(e){if(!e)return;let t=e.byteLength;this.bufferType===o.ELEMENT_ARRAY_BUFFER&&(U(e)&&(t/=2,this._indexType=E.UNSIGNED_SHORT),P(e)&&(t/=4,this._indexType=E.UNSIGNED_INT)),this._setBufferData(t,e)}_setBufferData(e,t=null){this._size=e;let i=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);let r=this._context.gl;t!=null?r.bufferData(this.bufferType,t,this.usage):r.bufferData(this.bufferType,e,this.usage),F(r),this._isVAOAware&&this._context.bindVAO(i)}setSubData(e,t,i,r){if(!e)return;(t<0||t*e.BYTES_PER_ELEMENT>=this.byteLength)&&u.error("offset is out of range!"),i>=r&&u.error("end must be bigger than start!"),(t+(r-i))*e.BYTES_PER_ELEMENT>this.byteLength&&u.error("An attempt to write beyond the end of the buffer!");let n=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);let h=this._context.gl;if(this._context.type===f.WEBGL2)h.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,e,i,r-i);else{let a=i===0&&r===e.length?e:e.subarray(i,r);h.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,a)}F(h),this._isVAOAware&&this._context.bindVAO(n)}getSubData(e,t=0,i,r){if(this._context.type!==f.WEBGL2)return void u.error("Get buffer subdata is supported in WebGL2 only!");if(i<0||r<0)return void u.error("Problem getting subdata: offset and length were less than zero!");let n=W(e)?e.BYTES_PER_ELEMENT:1;if(n*((i??0)+(r??0))>e.byteLength)return void u.error("Problem getting subdata: offset and length exceeded destination size!");t+n*(r??0)>this.byteLength&&u.warn("Potential problem getting subdata: requested data exceeds buffer size!");let h=this._context.gl;this._context.bindBuffer(this,o.COPY_READ_BUFFER),h.getBufferSubData(o.COPY_READ_BUFFER,t,e,i,r),this._context.unbindBuffer(o.COPY_READ_BUFFER)}getSubDataAsync(e,t=0,i,r){return R(this,null,function*(){this._context.type===f.WEBGL2?(yield this._context.clientWaitAsync(),this.getSubData(e,t,i,r)):u.error("Get buffer subdata is supported in WebGL2 only!")})}};function W(s){return M(s)}var G=class{constructor(e,t,i=t){this.internalFormat=e,this.width=t,this.height=i,this.multisampled=!1,this.samples=1}};function I(s){return s.width<=0||s.height<=0||s.internalFormat==null?0:s.width*s.height*H(s.internalFormat)}var N=class{constructor(e,t){this._context=e,this._descriptor=t,this.type=m.RenderBuffer,this._context.instanceCounter.increment(d.Renderbuffer,this);let i=this._context.gl;this.glName=i.createRenderbuffer(),this._context.bindRenderbuffer(this);let{width:r,height:n,internalFormat:h,multisampled:a}=t;if(a){if(this._context.type!==f.WEBGL2)throw new Error("Multisampled renderbuffers are not supported in WebGL1!");i.renderbufferStorageMultisample(i.RENDERBUFFER,this.samples,h,r,n)}else i.renderbufferStorage(i.RENDERBUFFER,h,r,n)}get descriptor(){return this._descriptor}get samples(){let e=this._descriptor.samples,t=this._context.parameters.maxSamples;return e?Math.min(e,t):t}get gpuMemoryUsage(){return I(this._descriptor)}resize(e,t){let i=this._descriptor;if(i.width===e&&i.height===t)return;i.width=e,i.height=t;let r=this._context.gl;this._context.bindRenderbuffer(this),i.multisampled?r.renderbufferStorageMultisample(r.RENDERBUFFER,this.samples,i.internalFormat,i.width,i.height):r.renderbufferStorage(r.RENDERBUFFER,i.internalFormat,i.width,i.height)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(d.Renderbuffer,this),this._context=null)}};var j=g.getLogger("esri.views.webgl.FramebufferObject"),w=class s{constructor(e,t,i=null){this._context=e,this._glName=null,this._colorAttachments=new Map,this._depthStencilBuffer=null,this._depthStencilTexture=null,this._initialized=!1,e.instanceCounter.increment(d.FramebufferObject,this);let r=D(t)?t:new x(this._context,t);if(this._colorAttachments.set(c.COLOR_ATTACHMENT0,r),this._validateTextureDescriptor(r.descriptor),this._validateColorAttachmentPoint(c.COLOR_ATTACHMENT0),i!=null)if(V(i))this._context.capabilities.depthTexture||console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"),this._depthStencilTexture=D(i)?i:new x(this._context,i),this._validateTextureDescriptor(this._depthStencilTexture.descriptor);else{let n=Y(i)?i:new N(this._context,i);this._depthStencilBuffer=n,this._validateRenderBufferDescriptor(n.descriptor)}}dispose(){if(this._colorAttachments.size===0&&!this._glName)return;let e=this._context.getBoundFramebufferObject();this._colorAttachments.forEach((t,i)=>this.detachColorTexture(i)?.dispose()),this.detachDepthStencilBuffer()?.dispose(),this.detachDepthStencilTexture()?.dispose(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(e),this._context.instanceCounter.decrement(d.FramebufferObject,this)}get glName(){return this._glName}get colorTexture(){return this._colorAttachments.get(c.COLOR_ATTACHMENT0)}get depthStencil(){return this._depthStencilTexture||this._depthStencilBuffer}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._colorAttachments.get(c.COLOR_ATTACHMENT0)?.descriptor?.width??0}get height(){return this._colorAttachments.get(c.COLOR_ATTACHMENT0)?.descriptor?.height??0}get gpuMemoryUsage(){return[...this._colorAttachments].reduce((e,[t,i])=>e+i.gpuMemoryUsage,this.depthStencil?.gpuMemoryUsage??0)}getColorTexture(e){let t=this._colorAttachments.get(e);return t&&D(t)?t:null}get colorAttachments(){return[...this._colorAttachments.keys()]}attachColorTexture(e,t=c.COLOR_ATTACHMENT0){if(!e)return;this._validateColorAttachmentPoint(t);let i=e.descriptor;this._validateTextureDescriptor(i),this.detachColorTexture(t)?.dispose(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(e.glName,t)),this._colorAttachments.set(t,e)}detachColorTexture(e=c.COLOR_ATTACHMENT0){let t=this._colorAttachments.get(e);if(t){if(this._initialized){let i=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e),this._context.bindFramebuffer(i)}return this._colorAttachments.delete(e),t}}setColorTextureTarget(e,t=c.COLOR_ATTACHMENT0){let i=this._colorAttachments.get(t);i&&this._framebufferTexture2D(i.glName,t,e)}attachDepthStencil(e){if(e)switch(e.type){case m.Texture:return this._attachDepthStencilTexture(e);case m.RenderBuffer:return this._attachDepthStencilBuffer(e)}}_attachDepthStencilTexture(e){if(e==null)return;let t=e.descriptor;t.pixelFormat!==C.DEPTH_STENCIL&&t.pixelFormat!==C.DEPTH24_STENCIL8&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),t.dataType!==z.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"),this._validateTextureDescriptor(t),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(e.glName,L)),this._depthStencilTexture?.dispose(),this._depthStencilTexture=e}detachDepthStencilTexture(){let e=this._depthStencilTexture;return e&&this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,L)),this._depthStencilTexture=null,e}_attachDepthStencilBuffer(e){if(e==null)return;let t=e.descriptor;if(this._validateRenderBufferDescriptor(t),this._disposeDepthStencilAttachments(),this._initialized){this._context.bindFramebuffer(this);let i=this._context.gl,r=this._getGLAttachmentPoint(t);i.framebufferRenderbuffer(b.FRAMEBUFFER,r,i.RENDERBUFFER,e.glName)}this._depthStencilBuffer=e}detachDepthStencilBuffer(){let e=this._depthStencilBuffer;if(e&&this._initialized){this._context.bindFramebuffer(this);let t=this._context.gl,i=this._getGLAttachmentPoint(e.descriptor);t.framebufferRenderbuffer(b.FRAMEBUFFER,i,t.RENDERBUFFER,null)}return this._depthStencilBuffer=null,e}copyToTexture(e,t,i,r,n,h,a){(e<0||t<0||n<0||h<0)&&console.error("Offsets cannot be negative!"),(i<=0||r<=0)&&console.error("Copy width and height must be greater than zero!");let p=a.descriptor;a.descriptor.target!==l.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),(p?.width==null||p?.height==null||e+i>this.width||t+r>this.height||n+i>p.width||h+r>p.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");let _=this._context,X=_.bindTexture(a,x.TEXTURE_UNIT_FOR_UPDATES);_.setActiveTexture(x.TEXTURE_UNIT_FOR_UPDATES),_.bindFramebuffer(this),_.gl.copyTexSubImage2D(l.TEXTURE_2D,0,n,h,e,t,i,r),_.bindTexture(X,x.TEXTURE_UNIT_FOR_UPDATES)}readPixels(e,t,i,r,n,h,a){(i<=0||r<=0)&&console.error("Copy width and height must be greater than zero!"),a||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(e,t,i,r,n,h,a)}readPixelsAsync(e,t,i,r,n,h,a){return R(this,null,function*(){if(this._context.type!==f.WEBGL2)return O()&&console.warn("Attempting to read pixels using pixel buffer object without WebGL2"),void this.readPixels(e,t,i,r,n,h,a);let p=this._context.gl,_=S.createPixelPack(this._context,A.STREAM_READ,a.byteLength);this._context.bindBuffer(_),this._context.bindFramebuffer(this),p.readPixels(e,t,i,r,n,h,0),this._context.unbindBuffer(o.PIXEL_PACK_BUFFER),yield _.getSubDataAsync(a),_.dispose()})}resize(e,t){if(this.width===e&&this.height===t)return;let i={width:e,height:t};B(i,this._context.parameters.maxTextureSize),this._colorAttachments.forEach(r=>r.resize(i.width,i.height)),this._depthStencilTexture?.resize(i.width,i.height),this._initialized&&(B(i,this._context.parameters.maxRenderbufferSize),this._depthStencilBuffer?.resize(i.width,i.height),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1)}initializeAndBind(e=b.FRAMEBUFFER){let t=this._context.gl;if(this._initialized)return void t.bindFramebuffer(e,this.glName);this._glName&&t.deleteFramebuffer(this._glName);let i=t.createFramebuffer();if(t.bindFramebuffer(e,i),this._colorAttachments.forEach((r,n)=>this._framebufferTexture2D(r.glName,n,v(r),e)),this._depthStencilBuffer){let r=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);t.framebufferRenderbuffer(e,r,t.RENDERBUFFER,this._depthStencilBuffer.glName)}else this._depthStencilTexture&&this._framebufferTexture2D(this._depthStencilTexture.glName,t.DEPTH_STENCIL_ATTACHMENT,v(this._depthStencilTexture),e);O()&&t.checkFramebufferStatus(e)!==t.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=i,this._initialized=!0}_framebufferTexture2D(e,t=c.COLOR_ATTACHMENT0,i=l.TEXTURE_2D,r=b.FRAMEBUFFER,n=0){this._context.gl.framebufferTexture2D(r,t,i,e,n)}_disposeDepthStencilAttachments(){let e=this._context.gl;if(this._depthStencilBuffer){if(this._initialized){this._context.bindFramebuffer(this);let t=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);e.framebufferRenderbuffer(b.FRAMEBUFFER,t,e.RENDERBUFFER,null)}this._depthStencilBuffer=y(this._depthStencilBuffer)}this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture=y(this._depthStencilTexture))}_validateTextureDescriptor(e){e.target!==l.TEXTURE_2D&&e.target!==l.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),B(e,this._context.parameters.maxTextureSize),this._validateBufferDimensions(e)}_validateRenderBufferDescriptor(e){B(e,this._context.parameters.maxRenderbufferSize),this._validateBufferDimensions(e)}_validateBufferDimensions(e){e.width<=0&&(e.width=this.width),e.height<=0&&(e.height=this.height),this.width>0&&this.height>0&&(this.width===e.width&&this.height===e.height||console.error("Attachment size must match framebuffer size!"))}_getGLAttachmentPoint(e){switch(e.internalFormat){case T.DEPTH_COMPONENT16:case T.DEPTH_COMPONENT24:case T.DEPTH_COMPONENT32F:return this._context.gl.DEPTH_ATTACHMENT;case T.DEPTH24_STENCIL8:case T.DEPTH32F_STENCIL8:case T.DEPTH_STENCIL:return this._context.gl.DEPTH_STENCIL_ATTACHMENT;case T.STENCIL_INDEX8:return this._context.gl.STENCIL_ATTACHMENT}}_validateColorAttachmentPoint(e){if(s._MAX_COLOR_ATTACHMENTS===-1){let i=this._context.capabilities.drawBuffers;if(i){let r=this._context.gl;s._MAX_COLOR_ATTACHMENTS=r.getParameter(i.MAX_COLOR_ATTACHMENTS)}else s._MAX_COLOR_ATTACHMENTS=1}let t=e-c.COLOR_ATTACHMENT0;t+1>s._MAX_COLOR_ATTACHMENTS&&g.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${t+1}. Implementation supports up to ${s._MAX_COLOR_ATTACHMENTS} color attachments`)}};function D(s){return s!=null&&"type"in s&&s.type===m.Texture}function Y(s){return s!=null&&"type"in s&&s.type===m.RenderBuffer}function V(s){return D(s)||s!=null&&"pixelFormat"in s}function B(s,e){let t=Math.max(s.width,s.height);if(t>e){j.warn(`Resizing FBO attachment size ${s.width}x${s.height} to device limit ${e}`);let i=e/t;return s.width=Math.round(s.width*i),s.height=Math.round(s.height*i),!1}return!0}function v(s){return s.descriptor.target===l.TEXTURE_CUBE_MAP?l.TEXTURE_CUBE_MAP_POSITIVE_X:l.TEXTURE_2D}w._MAX_COLOR_ATTACHMENTS=-1;export{S as a,G as b,N as c,w as d};
