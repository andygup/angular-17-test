import{c as ie,g as Q}from"./chunk-ESDYQQXO.js";var n={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,safari10:!1,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,cssVarShim:!1,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,dynamicImportShim:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!1,asyncQueue:!1,transformTagName:!1,attachStyles:!0};var O="app";var Pt=ie({});var k,Ce,N,We,qe=0,ke=!1,H=!1,te=!1,g=!1,le=null,K=0,U=!1,Ht={isDev:!!n.isDev,isBrowser:!0,isServer:!1,isTesting:!!n.isTesting};var Ut=e=>{let t=new URL(e,h.$resourcesUrl$);return t.origin!==x.location.origin?t.href:t.pathname},jt=e=>h.$resourcesUrl$=e,S=(e,t="")=>{if(n.profile&&performance.mark){let s=`st:${e}:${t}:${qe++}`;return performance.mark(s),()=>performance.measure(`[Stencil] ${e}() <${t}>`,s)}else return()=>{}},Qe=(e,t)=>n.profile&&performance.mark?(performance.getEntriesByName(e,"mark").length===0&&performance.mark(e),()=>{performance.getEntriesByName(t,"measure").length===0&&performance.measure(t,e)}):()=>{};var Ke="r",Xe="o",Ye="s",Je="t",Y="s-id",re="sty-id",ae="c-id";var ce="http://www.w3.org/1999/xlink",$e={},Ge="http://www.w3.org/2000/svg",Ze="http://www.w3.org/1999/xhtml",Ve=e=>e!=null,se=e=>(e=typeof e,e==="object"||e==="function");function et(e){var t,s,o;return(o=(s=(t=e.head)===null||t===void 0?void 0:t.querySelector('meta[name="csp-nonce"]'))===null||s===void 0?void 0:s.getAttribute("content"))!==null&&o!==void 0?o:void 0}var De=(e,t,...s)=>{let o=null,i=null,l=null,r=!1,a=!1,c=[],$=f=>{for(let u=0;u<f.length;u++)o=f[u],Array.isArray(o)?$(o):o!=null&&typeof o!="boolean"&&((r=typeof e!="function"&&!se(o))?o=String(o):n.isDev&&typeof e!="function"&&o.$flags$===void 0&&B(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),r&&a?c[c.length-1].$text$+=o:c.push(r?I(null,o):o),a=r)};if($(s),t&&(n.isDev&&e==="input"&&ot(t),n.vdomKey&&t.key&&(i=t.key),n.slotRelocation&&t.name&&(l=t.name),n.vdomClass)){let f=t.className||t.class;f&&(t.class=typeof f!="object"?f:Object.keys(f).filter(u=>f[u]).join(" "))}if(n.isDev&&c.some(J)&&B(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),n.vdomFunctional&&typeof e=="function")return e(t===null?{}:t,c,st);let d=I(e,null);return d.$attrs$=t,c.length>0&&(d.$children$=c),n.vdomKey&&(d.$key$=i),n.slotRelocation&&(d.$name$=l),d},I=(e,t)=>{let s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.vdomAttribute&&(s.$attrs$=null),n.vdomKey&&(s.$key$=null),n.slotRelocation&&(s.$name$=null),s},tt={},J=e=>e&&e.$tag$===tt,st={forEach:(e,t)=>e.map(de).forEach(t),map:(e,t)=>e.map(de).map(t).map(nt)},de=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),nt=e=>{if(typeof e.vtag=="function"){let s=Object.assign({},e.vattrs);return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),De(e.vtag,s,...e.vchildren||[])}let t=I(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},ot=e=>{let t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;let o=t.indexOf("type"),i=t.indexOf("min"),l=t.indexOf("max"),r=t.indexOf("step");(s<o||s<i||s<l||s<r)&&R('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},it=(e,t,s,o)=>{let i=S("hydrateClient",t),l=e.shadowRoot,r=[],a=[],c=n.shadowDom&&l?[]:null,$=o.$vnode$=I(t,null);h.$orgLocNodes$||Z(m.body,h.$orgLocNodes$=new Map),e[Y]=s,e.removeAttribute(Y),G($,r,a,c,e,e,s),r.map(d=>{let f=d.$hostId$+"."+d.$nodeId$,u=h.$orgLocNodes$.get(f),p=d.$elm$;u&&E&&u["s-en"]===""&&u.parentNode.insertBefore(p,u.nextSibling),l||(p["s-hn"]=t,u&&(p["s-ol"]=u,p["s-ol"]["s-nr"]=p)),h.$orgLocNodes$.delete(f)}),n.shadowDom&&l&&c.map(d=>{d&&l.appendChild(d)}),i()},G=(e,t,s,o,i,l,r)=>{let a,c,$,d;if(l.nodeType===1){for(a=l.getAttribute(ae),a&&(c=a.split("."),(c[0]===r||c[0]==="0")&&($={$flags$:0,$hostId$:c[0],$nodeId$:c[1],$depth$:c[2],$index$:c[3],$tag$:l.tagName.toLowerCase(),$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push($),l.removeAttribute(ae),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$,e=$,o&&$.$depth$==="0"&&(o[$.$index$]=$.$elm$))),d=l.childNodes.length-1;d>=0;d--)G(e,t,s,o,i,l.childNodes[d],r);if(l.shadowRoot)for(d=l.shadowRoot.childNodes.length-1;d>=0;d--)G(e,t,s,o,i,l.shadowRoot.childNodes[d],r)}else if(l.nodeType===8)c=l.nodeValue.split("."),(c[1]===r||c[1]==="0")&&(a=c[0],$={$flags$:0,$hostId$:c[1],$nodeId$:c[2],$depth$:c[3],$index$:c[4],$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},a===Je?($.$elm$=l.nextSibling,$.$elm$&&$.$elm$.nodeType===3&&($.$text$=$.$elm$.textContent,t.push($),l.remove(),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$,o&&$.$depth$==="0"&&(o[$.$index$]=$.$elm$))):$.$hostId$===r&&(a===Ye?($.$tag$="slot",c[5]?l["s-sn"]=$.$name$=c[5]:l["s-sn"]="",l["s-sr"]=!0,n.shadowDom&&o&&($.$elm$=m.createElement($.$tag$),$.$name$&&$.$elm$.setAttribute("name",$.$name$),l.parentNode.insertBefore($.$elm$,l),l.remove(),$.$depth$==="0"&&(o[$.$index$]=$.$elm$)),s.push($),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$):a===Ke&&(n.shadowDom&&o?l.remove():n.slotRelocation&&(i["s-cr"]=l,l["s-cn"]=!0))));else if(e&&e.$tag$==="style"){let f=I(null,l.textContent);f.$elm$=l,f.$index$="0",e.$children$=[f]}},Z=(e,t)=>{if(e.nodeType===1){let s=0;for(;s<e.childNodes.length;s++)Z(e.childNodes[s],t);if(e.shadowRoot)for(s=0;s<e.shadowRoot.childNodes.length;s++)Z(e.shadowRoot.childNodes[s],t)}else if(e.nodeType===8){let s=e.nodeValue.split(".");s[0]===Xe&&(t.set(s[1]+"."+s[2],e),e.nodeValue="",e["s-en"]=s[3])}},lt=e=>wt.map(t=>t(e)).find(t=>!!t);var rt=(e,t)=>e!=null&&!se(e)?n.propBoolean&&t&4?e==="false"?!1:e===""||!!e:n.propNumber&&t&2?parseFloat(e):n.propString&&t&1?String(e):e:e,at=e=>n.lazyLoad?L(e).$hostElement$:e,Bt=(e,t,s)=>{let o=at(e);return{emit:i=>(n.isDev&&!o.isConnected&&R(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),ne(o,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:i}))}},ne=(e,t,s)=>{let o=h.ce(t,s);return e.dispatchEvent(o),o},fe=new WeakMap,ct=(e,t,s)=>{let o=M.get(e);Et&&s?(o=o||new CSSStyleSheet,typeof o=="string"?o=t:o.replaceSync(t)):o=t,M.set(e,o)},V=(e,t,s,o)=>{var i;let l=we(t,s),r=M.get(l);if(!n.attachStyles)return l;if(e=e.nodeType===11?e:m,r)if(typeof r=="string"){e=e.head||e;let a=fe.get(e),c;if(a||fe.set(e,a=new Set),!a.has(l)){if(n.hydrateClientSide&&e.host&&(c=e.querySelector(`[${re}="${l}"]`)))c.innerHTML=r;else{if(n.cssVarShim&&h.$cssShim$){c=h.$cssShim$.createHostStyle(o,l,r,!!(t.$flags$&10));let d=c["s-sc"];d&&(l=d,a=null)}else c=m.createElement("style"),c.innerHTML=r;let $=(i=h.$nonce$)!==null&&i!==void 0?i:et(m);$!=null&&c.setAttribute("nonce",$),(n.hydrateServerSide||n.hotModuleReplacement)&&c.setAttribute(re,l),e.insertBefore(c,e.querySelector("link"))}a&&a.add(l)}}else n.constructableCSS&&!e.adoptedStyleSheets.includes(r)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,r]);return l},$t=e=>{let t=e.$cmpMeta$,s=e.$hostElement$,o=t.$flags$,i=S("attachStyles",t.$tagName$),l=V(n.shadowDom&&E&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$,s);(n.shadowDom||n.scoped)&&n.cssAnnotations&&o&10&&(s["s-sc"]=l,s.classList.add(l+"-h"),n.scoped&&o&2&&s.classList.add(l+"-s")),i()},we=(e,t)=>"sc-"+(n.mode&&t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$);var ue=(e,t,s,o,i,l)=>{if(s!==o){let r=be(e,t),a=t.toLowerCase();if(n.vdomClass&&t==="class"){let c=e.classList,$=he(s),d=he(o);c.remove(...$.filter(f=>f&&!d.includes(f))),c.add(...d.filter(f=>f&&!$.includes(f)))}else if(n.vdomStyle&&t==="style"){if(n.updatable)for(let c in s)(!o||o[c]==null)&&(!n.hydrateServerSide&&c.includes("-")?e.style.removeProperty(c):e.style[c]="");for(let c in o)(!s||o[c]!==s[c])&&(!n.hydrateServerSide&&c.includes("-")?e.style.setProperty(c,o[c]):e.style[c]=o[c])}else if(!(n.vdomKey&&t==="key")){if(n.vdomRef&&t==="ref")o&&o(e);else if(n.vdomListener&&(n.lazyLoad?!r:!e.__lookupSetter__(t))&&t[0]==="o"&&t[1]==="n")t[2]==="-"?t=t.slice(3):be(x,a)?t=a.slice(2):t=a[2]+t.slice(3),s&&h.rel(e,t,s,!1),o&&h.ael(e,t,o,!1);else if(n.vdomPropOrAttr){let c=se(o);if((r||c&&o!==null)&&!i)try{if(e.tagName.includes("-"))e[t]=o;else{let d=o??"";t==="list"?r=!1:(s==null||e[t]!=d)&&(e[t]=d)}}catch{}let $=!1;n.vdomXlink&&a!==(a=a.replace(/^xlink\:?/,""))&&(t=a,$=!0),o==null||o===!1?(o!==!1||e.getAttribute(t)==="")&&(n.vdomXlink&&$?e.removeAttributeNS(ce,t):e.removeAttribute(t)):(!r||l&4||i)&&!c&&(o=o===!0?"":o,n.vdomXlink&&$?e.setAttributeNS(ce,t,o):e.setAttribute(t,o))}}}},dt=/\s/,he=e=>e?e.split(dt):[],Ne=(e,t,s,o)=>{let i=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||$e,r=t.$attrs$||$e;if(n.updatable)for(o in l)o in r||ue(i,o,l[o],void 0,s,t.$flags$);for(o in r)ue(i,o,l[o],r[o],s,t.$flags$)},j=(e,t,s,o)=>{let i=t.$children$[s],l=0,r,a,c;if(n.slotRelocation&&!ke&&(te=!0,i.$tag$==="slot"&&(k&&o.classList.add(k+"-s"),i.$flags$|=i.$children$?2:1)),n.isDev&&i.$elm$&&B(`The JSX ${i.$text$!==null?`"${i.$text$}" text`:`"${i.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),n.vdomText&&i.$text$!==null)r=i.$elm$=m.createTextNode(i.$text$);else if(n.slotRelocation&&i.$flags$&1)r=i.$elm$=n.isDebug||n.hydrateServerSide?ut(i):m.createTextNode("");else{if(n.svg&&!g&&(g=i.$tag$==="svg"),r=i.$elm$=n.svg?m.createElementNS(g?Ge:Ze,n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$):m.createElement(n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$),n.svg&&g&&i.$tag$==="foreignObject"&&(g=!1),n.vdomAttribute&&Ne(null,i,g),(n.shadowDom||n.scoped)&&Ve(k)&&r["s-si"]!==k&&r.classList.add(r["s-si"]=k),i.$children$)for(l=0;l<i.$children$.length;++l)a=j(e,i,l,r),a&&r.appendChild(a);n.svg&&(i.$tag$==="svg"?g=!1:r.tagName==="foreignObject"&&(g=!0))}return n.slotRelocation&&(r["s-hn"]=N,i.$flags$&3&&(r["s-sr"]=!0,r["s-cr"]=Ce,r["s-sn"]=i.$name$||"",c=e&&e.$children$&&e.$children$[s],c&&c.$tag$===i.$tag$&&e.$elm$&&A(e.$elm$,!1))),r},A=(e,t)=>{h.$flags$|=1;let s=e.childNodes;for(let o=s.length-1;o>=0;o--){let i=s[o];i["s-hn"]!==N&&i["s-ol"]&&(Ae(i).insertBefore(i,oe(i)),i["s-ol"].remove(),i["s-ol"]=void 0,te=!0),t&&A(i,t)}h.$flags$&=-2},Ie=(e,t,s,o,i,l)=>{let r=n.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e,a;for(n.shadowDom&&r.shadowRoot&&r.tagName===N&&(r=r.shadowRoot);i<=l;++i)o[i]&&(a=j(null,s,i,e),a&&(o[i].$elm$=a,r.insertBefore(a,n.slotRelocation?oe(t):t)))},Ee=(e,t,s,o,i)=>{for(;t<=s;++t)(o=e[t])&&(i=o.$elm$,Oe(o),n.slotRelocation&&(H=!0,i["s-ol"]?i["s-ol"].remove():A(i,!0)),i.remove())},ft=(e,t,s,o)=>{let i=0,l=0,r=0,a=0,c=t.length-1,$=t[0],d=t[c],f=o.length-1,u=o[0],p=o[f],C,_;for(;i<=c&&l<=f;)if($==null)$=t[++i];else if(d==null)d=t[--c];else if(u==null)u=o[++l];else if(p==null)p=o[--f];else if(P($,u))D($,u),$=t[++i],u=o[++l];else if(P(d,p))D(d,p),d=t[--c],p=o[--f];else if(P($,p))n.slotRelocation&&($.$tag$==="slot"||p.$tag$==="slot")&&A($.$elm$.parentNode,!1),D($,p),e.insertBefore($.$elm$,d.$elm$.nextSibling),$=t[++i],p=o[--f];else if(P(d,u))n.slotRelocation&&($.$tag$==="slot"||p.$tag$==="slot")&&A(d.$elm$.parentNode,!1),D(d,u),e.insertBefore(d.$elm$,$.$elm$),d=t[--c],u=o[++l];else{if(r=-1,n.vdomKey){for(a=i;a<=c;++a)if(t[a]&&t[a].$key$!==null&&t[a].$key$===u.$key$){r=a;break}}n.vdomKey&&r>=0?(_=t[r],_.$tag$!==u.$tag$?C=j(t&&t[l],s,r,e):(D(_,u),t[r]=void 0,C=_.$elm$),u=o[++l]):(C=j(t&&t[l],s,l,e),u=o[++l]),C&&(n.slotRelocation?Ae($.$elm$).insertBefore(C,oe($.$elm$)):$.$elm$.parentNode.insertBefore(C,$.$elm$))}i>c?Ie(e,o[f+1]==null?null:o[f+1].$elm$,s,o,l,f):n.updatable&&l>f&&Ee(t,i,c)},P=(e,t)=>e.$tag$===t.$tag$?n.slotRelocation&&e.$tag$==="slot"?e.$name$===t.$name$:n.vdomKey?e.$key$===t.$key$:!0:!1,oe=e=>e&&e["s-ol"]||e,Ae=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,D=(e,t)=>{let s=t.$elm$=e.$elm$,o=e.$children$,i=t.$children$,l=t.$tag$,r=t.$text$,a;!n.vdomText||r===null?(n.svg&&(g=l==="svg"?!0:l==="foreignObject"?!1:g),(n.vdomAttribute||n.reflect)&&(n.slot&&l==="slot"||Ne(e,t,g)),n.updatable&&o!==null&&i!==null?ft(s,o,t,i):i!==null?(n.updatable&&n.vdomText&&e.$text$!==null&&(s.textContent=""),Ie(s,null,t,i,0,i.length-1)):n.updatable&&o!==null&&Ee(o,0,o.length-1),n.svg&&g&&l==="svg"&&(g=!1)):n.vdomText&&n.slotRelocation&&(a=s["s-cr"])?a.parentNode.textContent=r:n.vdomText&&e.$text$!==r&&(s.data=r)},Re=e=>{let t=e.childNodes,s,o,i,l,r,a;for(o=0,i=t.length;o<i;o++)if(s=t[o],s.nodeType===1){if(s["s-sr"]){for(r=s["s-sn"],s.hidden=!1,l=0;l<i;l++)if(a=t[l].nodeType,t[l]["s-hn"]!==s["s-hn"]||r!==""){if(a===1&&r===t[l].getAttribute("slot")){s.hidden=!0;break}}else if(a===1||a===3&&t[l].textContent.trim()!==""){s.hidden=!0;break}}Re(s)}},y=[],_e=e=>{let t,s,o,i,l,r,a=0,c=e.childNodes,$=c.length;for(;a<$;a++){if(t=c[a],t["s-sr"]&&(s=t["s-cr"])&&s.parentNode)for(o=s.parentNode.childNodes,i=t["s-sn"],r=o.length-1;r>=0;r--)s=o[r],!s["s-cn"]&&!s["s-nr"]&&s["s-hn"]!==t["s-hn"]&&(pe(s,i)?(l=y.find(d=>d.$nodeToRelocate$===s),H=!0,s["s-sn"]=s["s-sn"]||i,l?l.$slotRefNode$=t:y.push({$slotRefNode$:t,$nodeToRelocate$:s}),s["s-sr"]&&y.map(d=>{pe(d.$nodeToRelocate$,s["s-sn"])&&(l=y.find(f=>f.$nodeToRelocate$===s),l&&!d.$slotRefNode$&&(d.$slotRefNode$=l.$slotRefNode$))})):y.some(d=>d.$nodeToRelocate$===s)||y.push({$nodeToRelocate$:s}));t.nodeType===1&&_e(t)}},pe=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",Oe=e=>{n.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(Oe))},me=(e,t)=>{let s=e.$hostElement$,o=e.$cmpMeta$,i=e.$vnode$||I(null,null),l=J(t)?t:De(null,null,t);if(N=s.tagName,n.isDev&&Array.isArray(t)&&t.some(J))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${N.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);if(n.reflect&&o.$attrsToReflect$&&(l.$attrs$=l.$attrs$||{},o.$attrsToReflect$.map(([r,a])=>l.$attrs$[a]=s[r])),l.$tag$=null,l.$flags$|=4,e.$vnode$=l,l.$elm$=i.$elm$=n.shadowDom&&s.shadowRoot||s,(n.scoped||n.shadowDom)&&(k=s["s-sc"]),n.slotRelocation&&(Ce=s["s-cr"],ke=E&&(o.$flags$&1)!==0,H=!1),D(i,l),n.slotRelocation){if(h.$flags$|=1,te){_e(l.$elm$);let r,a,c,$,d,f,u=0;for(;u<y.length;u++)r=y[u],a=r.$nodeToRelocate$,a["s-ol"]||(c=n.isDebug||n.hydrateServerSide?ht(a):m.createTextNode(""),c["s-nr"]=a,a.parentNode.insertBefore(a["s-ol"]=c,a));for(u=0;u<y.length;u++)if(r=y[u],a=r.$nodeToRelocate$,r.$slotRefNode$){for($=r.$slotRefNode$.parentNode,d=r.$slotRefNode$.nextSibling,c=a["s-ol"];c=c.previousSibling;)if(f=c["s-nr"],f&&f["s-sn"]===a["s-sn"]&&$===f.parentNode&&(f=f.nextSibling,!f||!f["s-nr"])){d=f;break}(!d&&$!==a.parentNode||a.nextSibling!==d)&&a!==d&&(!a["s-hn"]&&a["s-ol"]&&(a["s-hn"]=a["s-ol"].parentNode.nodeName),$.insertBefore(a,d))}else a.nodeType===1&&(a.hidden=!0)}H&&Re(l.$elm$),h.$flags$&=-2,y.length=0}},ut=e=>m.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${N.toLowerCase()})`),ht=e=>m.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),Pe=(e,t)=>{n.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},W=(e,t)=>{if(n.taskQueue&&n.updatable&&(e.$flags$|=16),n.asyncLoading&&e.$flags$&4){e.$flags$|=512;return}Pe(e,e.$ancestorComponent$);let s=()=>pt(e,t);return n.taskQueue?At(s):s()},pt=(e,t)=>{let s=e.$hostElement$,o=S("scheduleUpdate",e.$cmpMeta$.$tagName$),i=n.lazyLoad?e.$lazyInstance$:s,l;return t?(n.lazyLoad&&n.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([r,a])=>v(i,r,a)),e.$queuedListeners$=null)),w(s,"componentWillLoad"),n.cmpWillLoad&&(l=v(i,"componentWillLoad"))):(w(s,"componentWillUpdate"),n.cmpWillUpdate&&(l=v(i,"componentWillUpdate"))),w(s,"componentWillRender"),n.cmpWillRender&&(l=ve(l,()=>v(i,"componentWillRender"))),o(),ve(l,()=>mt(e,i,t))},mt=(e,t,s)=>Q(void 0,null,function*(){let o=e.$hostElement$,i=S("update",e.$cmpMeta$.$tagName$),l=o["s-rc"];n.style&&s&&$t(e);let r=S("render",e.$cmpMeta$.$tagName$);if(n.isDev&&(e.$flags$|=1024),n.hydrateServerSide?yield ge(e,t,o):ge(e,t,o),n.cssVarShim&&h.$cssShim$&&h.$cssShim$.updateHost(o),n.isDev&&(e.$renderCount$++,e.$flags$&=-1025),n.hydrateServerSide)try{He(o),s&&(e.$cmpMeta$.$flags$&1?o["s-en"]="":e.$cmpMeta$.$flags$&2&&(o["s-en"]="c"))}catch(a){b(a,o)}if(n.asyncLoading&&l&&(l.map(a=>a()),o["s-rc"]=void 0),r(),i(),n.asyncLoading){let a=o["s-p"],c=()=>ye(e);a.length===0?c():(Promise.all(a).then(c),e.$flags$|=4,a.length=0)}else ye(e)}),ge=(e,t,s)=>{let o=!!n.allRenderFn,i=!!n.lazyLoad,l=!!n.taskQueue,r=!!n.updatable;try{if(le=t,t=(o||t.render)&&t.render(),r&&l&&(e.$flags$&=-17),(r||i)&&(e.$flags$|=2),n.hasRenderFn||n.reflect)if(n.vdomRender||n.reflect){if(n.hydrateServerSide)return Promise.resolve(t).then(a=>me(e,a));me(e,t)}else s.textContent=t}catch(a){b(a,e.$hostElement$)}return le=null,null};var ye=e=>{let t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,o=S("postUpdate",t),i=n.lazyLoad?e.$lazyInstance$:s,l=e.$ancestorComponent$;n.cmpDidRender&&(n.isDev&&(e.$flags$|=1024),v(i,"componentDidRender"),n.isDev&&(e.$flags$&=-1025)),w(s,"componentDidRender"),e.$flags$&64?(n.cmpDidUpdate&&(n.isDev&&(e.$flags$|=1024),v(i,"componentDidUpdate"),n.isDev&&(e.$flags$&=-1025)),w(s,"componentDidUpdate"),o()):(e.$flags$|=64,n.asyncLoading&&n.cssAnnotations&&ze(s),n.cmpDidLoad&&(n.isDev&&(e.$flags$|=2048),v(i,"componentDidLoad"),n.isDev&&(e.$flags$&=-2049)),w(s,"componentDidLoad"),o(),n.asyncLoading&&(e.$onReadyResolve$(s),l||gt(t))),n.hotModuleReplacement&&s["s-hmr-load"]&&s["s-hmr-load"](),n.method&&n.lazyLoad&&e.$onInstanceResolve$(s),n.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&q(()=>W(e,!1)),e.$flags$&=-517)},Mt=e=>{if(n.updatable){let t=L(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&W(t,!1),s}return!1},gt=e=>{n.cssAnnotations&&ze(m.documentElement),n.asyncQueue&&(h.$flags$|=2),q(()=>ne(x,"appload",{detail:{namespace:O}})),n.profile&&performance.measure&&performance.measure(`[Stencil] ${O} initial load (by ${e})`,"st:app:start")},v=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(o){b(o)}},ve=(e,t)=>e&&e.then?e.then(t):t(),w=(e,t)=>{n.lifecycleDOMEvents&&ne(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:O}})},ze=e=>n.hydratedClass?e.classList.add("hydrated"):n.hydratedAttribute?e.setAttribute("hydrated",""):void 0,He=e=>{let t=e.children;if(t!=null)for(let s=0,o=t.length;s<o;s++){let i=t[s];typeof i.connectedCallback=="function"&&i.connectedCallback(),He(i)}},yt=(e,t)=>L(e).$instanceValues$.get(t),vt=(e,t,s,o)=>{let i=L(e),l=n.lazyLoad?i.$hostElement$:e,r=i.$instanceValues$.get(t),a=i.$flags$,c=n.lazyLoad?i.$lazyInstance$:l;s=rt(s,o.$members$[t][0]);let $=Number.isNaN(r)&&Number.isNaN(s),d=s!==r&&!$;if((!n.lazyLoad||!(a&8)||r===void 0)&&d&&(i.$instanceValues$.set(t,s),n.isDev&&(i.$flags$&1024?R(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,l,`
New value`,s,`
Old value`,r):i.$flags$&2048&&R(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,l,`
New value`,s,`
Old value`,r)),!n.lazyLoad||c)){if(n.watchCallback&&o.$watchers$&&a&128){let f=o.$watchers$[t];f&&f.map(u=>{try{c[u](s,r,t)}catch(p){b(p,l)}})}if(n.updatable&&(a&18)===2){if(n.cmpShouldUpdate&&c.componentShouldUpdate&&c.componentShouldUpdate(s,r,t)===!1)return;W(i,!1)}}},Ue=(e,t,s)=>{if(n.member&&t.$members$){n.watchCallback&&e.watchers&&(t.$watchers$=e.watchers);let o=Object.entries(t.$members$),i=e.prototype;if(o.map(([l,[r]])=>{(n.prop||n.state)&&(r&31||(!n.lazyLoad||s&2)&&r&32)?Object.defineProperty(i,l,{get(){return yt(this,l)},set(a){if(n.isDev){let c=L(this);!(s&1)&&!(c.$flags$&8)&&r&31&&!(r&1024)&&R(`@Prop() "${l}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}vt(this,l,a,t)},configurable:!0,enumerable:!0}):n.lazyLoad&&n.method&&s&1&&r&64&&Object.defineProperty(i,l,{value(...a){let c=L(this);return c.$onInstancePromise$.then(()=>c.$lazyInstance$[l](...a))}})}),n.observeAttribute&&(!n.lazyLoad||s&1)){let l=new Map;i.attributeChangedCallback=function(r,a,c){h.jmp(()=>{let $=l.get(r);if(this.hasOwnProperty($))c=this[$],delete this[$];else if(i.hasOwnProperty($)&&typeof this[$]=="number"&&this[$]==c)return;this[$]=c===null&&typeof this[$]=="boolean"?!1:c})},e.observedAttributes=o.filter(([r,a])=>a[0]&15).map(([r,a])=>{let c=a[1]||r;return l.set(c,r),n.reflect&&a[0]&512&&t.$attrsToReflect$.push([r,c]),c})}}return e},Se=(e,t,s,o,i)=>Q(void 0,null,function*(){if((n.lazyLoad||n.hydrateServerSide||n.style)&&!(t.$flags$&32)){if(n.lazyLoad||n.hydrateClientSide){if(t.$flags$|=32,i=Dt(s,t,o),i.then){let c=Qe(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);i=yield i,c()}if((n.isDev||n.isDebug)&&!i)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);n.member&&!i.isProxied&&(n.watchCallback&&(s.$watchers$=i.watchers),Ue(i,s,2),i.isProxied=!0);let a=S("createInstance",s.$tagName$);n.member&&(t.$flags$|=8);try{new i(t)}catch(c){b(c)}n.member&&(t.$flags$&=-9),n.watchCallback&&(t.$flags$|=128),a(),je(t.$lazyInstance$)}else i=e.constructor,t.$flags$|=32,customElements.whenDefined(s.$tagName$).then(()=>t.$flags$|=128);if(n.style&&i.style){let a=i.style;n.mode&&typeof a!="string"&&(a=a[t.$modeName$=lt(e)],n.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));let c=we(s,t.$modeName$);if(!M.has(c)){let $=S("registerStyles",s.$tagName$);!n.hydrateServerSide&&n.shadowDom&&n.shadowDomShim&&s.$flags$&8&&(a=yield import("./chunk-RZOFS5W5.js").then(d=>d.scopeCss(a,c,!1))),ct(c,a,!!(s.$flags$&1)),$()}}}let l=t.$ancestorComponent$,r=()=>W(t,!0);n.asyncLoading&&l&&l["s-rc"]?l["s-rc"].push(r):r()}),je=e=>{n.lazyLoad&&n.connectedCallback&&v(e,"connectedCallback")},St=e=>{if(!(h.$flags$&1)){let t=L(e),s=t.$cmpMeta$,o=S("connectedCallback",s.$tagName$);if(n.hostListenerTargetParent&&ee(e,t,s.$listeners$,!0),t.$flags$&1)ee(e,t,s.$listeners$,!1),je(t.$lazyInstance$);else{t.$flags$|=1;let i;if(n.hydrateClientSide&&(i=e.getAttribute(Y),i)){if(n.shadowDom&&E&&s.$flags$&1){let l=n.mode?V(e.shadowRoot,s,e.getAttribute("s-mode")):V(e.shadowRoot,s);e.classList.remove(l+"-h",l+"-s")}it(e,s.$tagName$,i,t)}if(n.slotRelocation&&!i&&(n.hydrateServerSide||(n.slot||n.shadowDom)&&s.$flags$&12)&&bt(e),n.asyncLoading){let l=e;for(;l=l.parentNode||l.host;)if(n.hydrateClientSide&&l.nodeType===1&&l.hasAttribute("s-id")&&l["s-p"]||l["s-p"]){Pe(t,t.$ancestorComponent$=l);break}}n.prop&&!n.hydrateServerSide&&s.$members$&&Object.entries(s.$members$).map(([l,[r]])=>{if(r&31&&e.hasOwnProperty(l)){let a=e[l];delete e[l],e[l]=a}}),n.initializeNextTick?q(()=>Se(e,t,s)):Se(e,t,s)}o()}},bt=e=>{let t=e["s-cr"]=m.createComment(n.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},Lt=e=>{if(!(h.$flags$&1)){let t=L(e),s=n.lazyLoad?t.$lazyInstance$:e;n.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map(o=>o()),t.$rmListeners$=void 0),n.cssVarShim&&h.$cssShim$&&h.$cssShim$.removeHost(e),n.lazyLoad&&n.disconnectedCallback&&v(s,"disconnectedCallback"),n.cmpDidUnload&&v(s,"componentDidUnload")}};var Ft=(e,t)=>{let s={$flags$:t[0],$tagName$:t[1]};n.member&&(s.$members$=t[2]),n.hostListener&&(s.$listeners$=t[3]),n.watchCallback&&(s.$watchers$=e.$watchers$),n.reflect&&(s.$attrsToReflect$=[]),n.shadowDom&&!E&&s.$flags$&1&&(s.$flags$|=8);let o=e.prototype.connectedCallback,i=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){kt(this,s)},connectedCallback(){St(this),n.connectedCallback&&o&&o.call(this)},disconnectedCallback(){Lt(this),n.disconnectedCallback&&i&&i.call(this)},__attachShadow(){E?n.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)}):this.attachShadow({mode:"open"}):this.shadowRoot=this}}),e.is=s.$tagName$,Ue(e,s,3)};var Wt=(e,t)=>t,ee=(e,t,s,o)=>{n.hostListener&&s&&(n.hostListenerTargetParent&&(o?s=s.filter(([i])=>i&32):s=s.filter(([i])=>!(i&32))),s.map(([i,l,r])=>{let a=n.hostListenerTarget?xt(e,i):e,c=Tt(t,r),$=Ct(i);h.ael(a,l,c,$),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>h.rel(a,l,c,$))}))},Tt=(e,t)=>s=>{try{n.lazyLoad?e.$flags$&256?e.$lazyInstance$[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s]):e.$hostElement$[t](s)}catch(o){b(o)}},xt=(e,t)=>n.hostListenerTargetDocument&&t&4?m:n.hostListenerTargetWindow&&t&8?x:n.hostListenerTargetBody&&t&16?m.body:n.hostListenerTargetParent&&t&32?e.parentElement:e,Ct=e=>Nt?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;var Be=new WeakMap,L=e=>Be.get(e);var kt=(e,t)=>{let s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return n.isDev&&(s.$renderCount$=0),n.method&&n.lazyLoad&&(s.$onInstancePromise$=new Promise(o=>s.$onInstanceResolve$=o)),n.asyncLoading&&(s.$onReadyPromise$=new Promise(o=>s.$onReadyResolve$=o),e["s-p"]=[],e["s-rc"]=[]),ee(e,s,t.$listeners$,!1),Be.set(e,s)},be=(e,t)=>t in e,b=(e,t)=>(We||console.error)(e,t),Me=n.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],B=(...e)=>console.error(...Me,...e),R=(...e)=>console.warn(...Me,...e);var Le=new Map,Dt=(e,t,s)=>{let o=e.$tagName$.replace(/-/g,"_"),i=e.$lazyBundleId$;if(n.isDev&&typeof i!="string"){B(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}let l=n.hotModuleReplacement?!1:Le.get(i);if(l)return l[o];return Pt(`./${i}.entry.js${n.hotModuleReplacement&&s?"?s-hmr="+s:""}`).then(r=>(n.hotModuleReplacement||Le.set(i,r),r[o]),b)},M=new Map,wt=[],x=typeof window<"u"?window:{},qt=n.cssVarShim?x.CSS:null,m=x.document||{head:{}},Qt=x.HTMLElement||class{},h={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,o)=>e.addEventListener(t,s,o),rel:(e,t,s,o)=>e.removeEventListener(t,s,o),ce:(e,t)=>new CustomEvent(e,t)};var E=n.shadowDomShim&&n.shadowDom?(()=>(m.head.attachShadow+"").indexOf("[native")>-1)():!0,Nt=(()=>{let e=!1;try{m.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),It=e=>Promise.resolve(e),Et=n.constructableCSS?(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})():!1,z=[],T=[],X=[],Fe=(e,t)=>s=>{e.push(s),U||(U=!0,t&&h.$flags$&4?q(F):h.raf(F))},Te=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){b(s)}e.length=0},xe=(e,t)=>{let s=0,o=0;for(;s<e.length&&(o=performance.now())<t;)try{e[s++](o)}catch(i){b(i)}s===e.length?e.length=0:s!==0&&e.splice(0,s)},F=()=>{if(n.asyncQueue&&K++,Te(z),n.asyncQueue){let e=(h.$flags$&6)===2?performance.now()+14*Math.ceil(K*.1):1/0;xe(T,e),xe(X,e),T.length>0&&(X.push(...T),T.length=0),(U=z.length+T.length+X.length>0)?h.raf(F):K=0}else Te(T),(U=z.length>0)&&h.raf(F)},q=e=>It().then(e),Kt=Fe(z,!1),At=Fe(T,!0);export{Ht as a,Ut as b,jt as c,De as d,tt as e,Bt as f,Mt as g,Ft as h,Wt as i,Qt as j,Kt as k};
